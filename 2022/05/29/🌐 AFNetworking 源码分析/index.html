<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 🌐 AFNetworking 源码分析 · jjakj1's blog</title><meta name="description" content="🌐 AFNetworking 源码分析 - Shanyu Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="../../../../maze.png"><link rel="stylesheet" href="../../../../css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="jjakj1's blog"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="jjakj1's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="../../../../index.html"><img src="../../../../videogame.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="../../../../index.html" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/jjakj1" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../archives/" target="_self">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">🌐 AFNetworking 源码分析</h1><div class="post-info">May 29, 2022</div><div class="post-content"><p>研究了 AFNetworking 网络框架的主要结构和方法，对其内部如何建立一个请求，做了哪些额外工作，特别是如何发送一个 multipart request 请求进行了较为深入的分析。</p>
<span id="more"></span>

<p>AFNetworking 作为 iOS 最著名的网络框架之一，对官方 <code>NSURLSession</code> 一系列 API 进行了封装，提供了大量更方便使用的接口。</p>
<p>对于这样一种框架，我认为想要了解其相对于原生 API 的优势，首先就需要对两者 API 的使用有一定的了解，在阅读其源码前，我写了一个 Demo。Demo 使用的网络请求类中同时提供接口相同的、但内部分别由原生 API 和 AFNetworking API 实现，以此来感受双方 API 的差异性。详情可以参考 <a target="_blank" rel="noopener" href="https://github.com/jjakj1/AFNetworkingDemo">Github</a> 中的 <code>NetworkingDataManager</code> 类。（其实最开始进行对比的时候，我没有特别感受到 AFNetworking 相对于原生 API 方便很多，可能更多细节在于对于错误情况的处理和数据的转换上，这个需要等阅读源码后才能得出结论）</p>
<h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p><code>AFURLSessionManger</code> 作为调用 AFNetworking 所提供的 API 的类，大致结构如下：</p>
<p><img src="https://res.craft.do/user/full/ea081854-0d6c-dace-b07b-5007ad758cc9/doc/BAA570CA-8DD7-4D68-9E22-C44B50358FF0/BE908F8C-99D6-49B7-A074-E0B057FB241D_2/VaA0yRAbWDxG6ohe6papFFzxtYxxrh4ZyFVBBg71ynQz/AFURLSessionManager.png" alt="AFURLSessionManager.png"></p>
<p>其中 <code>AFURLSessionManager</code> 自身实现了几个官方的 Delegate，并提供了一系列的 block 作为属性，让外界去设置。内部私有了一个 <code>AFURLSessionManagerTaskDelegate</code> 类，其实现了除 <code>NSURLSessionDelegate</code> 之外其他三个 Delegate 的大部分方法。</p>
<p><code>AFURLSessionManager</code> 内部最重要的结构是一个字典，其使用创建的各个 <code>URLSessionTask</code> 的 identifier 作为键，并将一个 <code>AFURLSessionManagerTaskDelegate</code> 对象作为值，该对象会在每次创建一个新的 task 时被同时创建，并将一些为了实现三种代理中方法所需要的 block 传入进去。Delegate 最终会在 <code>URLSession:task:didCompleteWithError:</code> 中被释放</p>
<p><code>AFURLSessionManager</code> 处理一个代理方法最普遍的行为实际上分为两种情况：</p>
<ul>
<li><code>AFURLSessionManagerTaskDelegate</code> 如果也实现了那个代理方法，就会从字典里找到当前 task 对应的 Delegate 并调用 Delegate 里面的对应代理方法。</li>
<li>如果 <code>AFURLSessionManagerTaskDelegate</code> 没有实现该方法，就判断对应的 block 是否被设置，如果进行了设置，则调用该 block。</li>
</ul>
<p>另外内部还保存并默认设置了以下属性来对内部的状态和数据进行处理，后续也会进行分析。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer; <span class="comment">// default is AFJSONResponseSerializer</span></span><br></pre></td></tr></table></figure>

<h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p>继承了 <code>AFURLSessionManager</code> ，内部基本一致，添加了 <code>AFHTTPRequestSerializer</code> 属性。并默认提供了一个 <code>AFHTTPRequestSerializer</code> 作为其默认值。同时对于 <code>requestSerializer</code> 属性的定义也有所变化，但默认赋值还是 <code>AFJSONResponseSerializer</code> 。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In AFURLSessionManager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class="line"><span class="comment">// In AFHTTPSessionManager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer</span><br></pre></td></tr></table></figure>

<p>添加了一个 <code>baseURL</code> 属性，方便在之后的请求中，只用提供剩下的文件路径。</p>
<p>主要提供了一些带有 HTTP method （GET、POST 等）的 data task 相关方法，其内部实现基本都是直接调用了下面的这个私有方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                         headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                  uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                                         failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br></pre></td></tr></table></figure>

<p>该方法中利用 <code>AFHTTPRequestSerializer</code> 来将 <code>method</code> <code>URLString</code> 和 <code>paramters</code> 合并成一个 <code>NSMutableURLRequest</code> 并遍历所有的 <code>headers</code> 中的键值对。来使用 <code>setValue: forHTTPHeaderField:</code> 方法更改 Header 中的值，最后调用父类中创建 data task 的方法。</p>
<h2 id="AFHTTPRequestSerializer"><a href="#AFHTTPRequestSerializer" class="headerlink" title="AFHTTPRequestSerializer"></a>AFHTTPRequestSerializer</h2><p><code>AFHTTPRequestSerializer</code> 实现了协议 <code>AFURLRequestSerialization</code> 。该协议提供了以下的方法，而 <code>AFHTTPRequestSerializer</code> 也就是通过调用这个方法来将一个 request 和 parameters 进行序列化，从而生成一个新的 request，这个方法的详细实现将在后续讲述。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                        withParameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                                 error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br></pre></td></tr></table></figure>

<p><code>AFHTTPRequestSerializer</code> 的初始化过程主要干了 3 件事：</p>
<ol>
<li>通过 <code>[NSLocale preferredLanguages]</code> 从设置从取出本机偏好的语言顺序，并使用此信息设置 HTTP header 中的 <strong>Accept-Language</strong> 。</li>
<li>通过 bundle 或 device 的信息设置 HTTP header 中的 <strong>User-Agent</strong> 。</li>
<li>使用 KVO 将自身作为监听者，监听内部一些其他属性的变动。如 <code>allowsCellularAccess</code> <code>HTTPShouldHandleCookies</code> 等，这些也都是 <code>NSURLRequest</code> 的一些属性。属性会在变动时，被加入内部的 <code>mutableObservedChangedKeyPaths</code> 属性中，该属性是一个 <code>NSMutableSet</code> 。</li>
</ol>
<p>除此之外，该类还提供了一些用于设置 HTTP header 的方法，如：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setValue:(<span class="built_in">NSString</span> *)value</span><br><span class="line">forHTTPHeaderField:(<span class="built_in">NSString</span> *)field;</span><br></pre></td></tr></table></figure>

<p>被设置 value 和 field 都会以键值对的形式存放在内部的一个 <code>NSMutableDictionary</code> 中，直到最后调用上面的序列化方法时才会被集体使用，通过调用 <code>setValue:forHTTPHeaderField:</code> 方法设置最终 request 的 HTTP header Field。</p>
<p>一个细节是，为了保证在 set header 时的线程安全，在设置时内部使用了 <code>dispatch_barrier_sync</code> 。</p>
<h3 id="非-multipart-request"><a href="#非-multipart-request" class="headerlink" title="非 multipart request"></a>非 multipart request</h3><p><code>AFHTTPRequestSerializer</code> 另外的核心 API 可以分为生成 multipart request 部分和非 multipart request 两个部分来看。首先介绍非 multipart request 部分。其接口如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                          URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                         parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                              error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br></pre></td></tr></table></figure>

<p>调用该方法时，其内部主要做了三件事：</p>
<ol>
<li>通过 URLString 生成一个 URLRequest，并将该请求的 method 设置为指定的 method。</li>
<li>遍历更改过的属性列表 <code>mutableObservedChangedKeyPaths</code> ，使用 <code>setValue:forKey:</code> 方法去改变 request 中对应属性的值。</li>
<li>调用上面的序列化方法，传入生成的这个 request 以及参数中的 parameters 和 error。</li>
</ol>
<p>接下来我们看看序列化方法内部过程。其方法内部大概步骤如下：</p>
<ol>
<li><code>mutableCopy</code> 传入的 request，并将 serializer 内部之前设置的 headers 通过 <code>setValue:forHTTPField:</code> 设置到 request 上。</li>
<li>如果传入的 parameters 不为空，首先看外部有没有指定一个 block 来处理 parameter（通过一个 property 设置），有就通过这个 block 处理 parameters，如果没有就将它们转换为 <code>key=value</code> 的形式并用 <code>&amp;</code> 串联成一个字符串，作为 query。</li>
<li>最后如果请求方法是 GET, HEAD, DELETE 中的一种，就直接吧 query 拼接在 request 的 URL 上。如果不是而且 request 没有 <strong>Content-Type</strong> 就将其设置为 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST">application&#x2F;x-www-form-urlencoded</a>，然后把 query 转换为 <code>NSData</code> 设置到 HTTP 的 body 上。</li>
<li>返回上面处理好的 request。</li>
</ol>
<h3 id="Multipart-request"><a href="#Multipart-request" class="headerlink" title="Multipart request"></a>Multipart request</h3><p>首先我们要明白 multipart request 结构是什么样的。使用 Postman 发送网络请求可以指定 body 格式为 form-data（method 类型不能是 GET 和 HEAD），表示以表单形式提交，表单数据将会被处理成一条请求，此时发送的就是一个 multipart request。同时发送这类请求我们可以指定 value 是一个文件。</p>
<p><img src="https://res.craft.do/user/full/ea081854-0d6c-dace-b07b-5007ad758cc9/doc/BAA570CA-8DD7-4D68-9E22-C44B50358FF0/A7762D1C-23C0-4C22-BDB5-1B57A4D45E02_2/dxyIZJfqN7r5cBrqTGtYxYWPNlu8HmnqvBvCB3LmOngz/Image.png" alt="Image.png"></p>
<p>我们接下来通过实际发送的 HTTP 包来看一下 multipart request 的具体格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">POST /post HTTP/1.1</span><br><span class="line">User-Agent: PostmanRuntime/7.29.0</span><br><span class="line">Accept: */*</span><br><span class="line">Postman-Token: d3f08e2a-5e01-4f6a-9279-2689018f30eb</span><br><span class="line">Host: httpbin.org</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: multipart/form-data; boundary=--------------------------833910809558491007284810</span><br><span class="line">Content-Length: 1250051</span><br><span class="line"></span><br><span class="line">----------------------------833910809558491007284810</span><br><span class="line">Content-Disposition: form-data; name=&quot;Hello&quot;; filename=&quot;Hello.swift&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">print(&quot;hello world&quot;)</span><br><span class="line">----------------------------833910809558491007284810</span><br><span class="line">Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;Pid89915350.jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line"># image raw data</span><br><span class="line">----------------------------833910809558491007284810</span><br><span class="line">Content-Disposition: form-data; name=&quot;key1&quot;</span><br><span class="line"></span><br><span class="line">value1</span><br><span class="line">----------------------------833910809558491007284810--</span><br></pre></td></tr></table></figure>

<p>从上面可以看出其几个特点：</p>
<ul>
<li><strong>Content-Type</strong> 对应的值是 <strong>multipart&#x2F;form-data</strong> 表示这是一个 multipart request。</li>
<li>Content-Type 后面指定了一个分割符 boundary。后续在 body 中也是通过这个分割符分割不同的键值对。</li>
<li>body 中除了用分割符分割键值对之外，每个键值对都会指定 <strong>Content-Disposition</strong> 属性，如果是文件，还会在后面带上 filename。</li>
<li>如果是文件，还会根据文件类型指定 <strong>Content-Type</strong> 。</li>
</ul>
<p>了解完了 multiple request 的基本概念，下面来看看 AFNetworking 框架怎么处理这种请求。</p>
<p>下面是一些内部创建的类，AFNetworking 通过这些类来处理 multiple request 请求，这些类会在后面创建 request 的流程中进行更详细的介绍：</p>
<p><img src="https://res.craft.do/user/full/ea081854-0d6c-dace-b07b-5007ad758cc9/doc/BAA570CA-8DD7-4D68-9E22-C44B50358FF0/B94B9153-DB9A-4272-AC7E-97E551F23EB8_2/raPlHT80coNtIOSDen7w3Z74hyjDcOz9v2P2mLC4MY0z/AFMultipartFormData.png" alt="AFMultipartFormData.png"></p>
<p>AFNetworking 通过如下方法创建一个 multipart request：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)multipartFormRequestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                              URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                             parameters:(<span class="built_in">NSDictionary</span> *)parameters</span><br><span class="line">                              constructingBodyWithBlock:(<span class="type">void</span> (^)(<span class="type">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                                  error:(<span class="built_in">NSError</span> *__autoreleasing *)error;</span><br></pre></td></tr></table></figure>

<p>方法内部首先通过上面的 <code>requestWithMethod:URLString:parameters:error:</code> 方法创建一个带 method 的 request，但由于 multipart request 中的 parameters 的 key 可能是文件，因此调用该方法时 parameters 参数传入的是 <code>nil</code> 。</p>
<p>随后使用该创建的 request 初始化一个 <code>AFStreamingMultipartFormData</code> ，该类在初始化时会随机生成 multipart request 需要的分割符（boundary）。同时内部初始化一个 <code>AFMultipartBodyStream</code> 作为其属性 ，该类继承了 <code>NSInputStream</code> 并实现了 <code>NSStreamDelegate</code> 中的方法。再对数据进行处理后将在最后被设置到 request 的 httpBodyStream 上。</p>
<p>创建结束后，内部会遍历 parameters，对那些不是 <code>NSData</code> 的 value 进行转换（可能是普通字符类型），统一成 <code>NSData</code> 类型，随后调用 <code>AFStreamMultipartFormData</code> 的 <code>appendPartWithFormData:name:</code> 方法将其挨个加入到 form data 中。这个添加过程又分为以下几步：</p>
<ol>
<li>首先创建了一个 dictionary，然后设置了 <strong>Content-Disposition</strong> 值。</li>
<li>随后创建了一个 <code>AFHTTPBodyPart</code> 实例，每一个 <code>AFHTTPBodyPart</code> 的实例，其实就是代表了上面我们看到了 multipart request HTTP 头里面两个分割线之间的一块内容（一个键值对）。创建后将上面设置过的 dictionary 作为了 bodyPart 的 headers，传入的 data 作为其 body，同时设置了分割符和 content length。</li>
<li>最后将生成的这个 body part 加到上面生成的 body stream 里面。这个加入逻辑实际上就是将这个新生成 body part 放到了内部的一个 array 中。</li>
</ol>
<p>随后会调用参数中的 block，并将创建的 formData 实例传入。在 block 中，使用者可以调用 <code>AFMultipartFormData</code> 协议中的一些其他方法，将数据添加到 multipart request 的 body 中。比如:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)appendPartWithFileURL:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                         name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br></pre></td></tr></table></figure>

<p>会通过在内部设置 <strong>Content-Disposition</strong> 和 <strong>Content-Type</strong> ，同样也生成一个 <code>AFHTTPBodyPart</code> 实例，并设置其 headers、body（设置为这里的 fileURL）等属性，最后添加到 body stream 里面。</p>
<p>multipart request 方法最后会调用 form data 的 <code>requestByFinalizingMultipartFormData</code> 方法生成一个 request 返回。该方法内部生成了一个 request，设置了其 <strong>Content-Type</strong> 为 <strong>multipart&#x2F;form-data; boundary&#x3D;…</strong>，同时 <strong>Content-Length</strong> 为 body stream 的大小<strong>。</strong>并设置了其 http body stream 为上面的 <code>AFMultipartBodyStream</code> 实例。另外还指定只有第一个和最后一个 body part 分别需要初始分割符和结束分割符。</p>
<p>由于 <code>AFMultipartBodyStream</code> 继承了 <code>NSInputStream</code> ，实际要去看发送时如何处理内部的 headers 和 body 还是需要去看它如何重写了 <code>read:maxLength:</code> 方法。该方法内部实现就是遍历内部的所有 <code>AFHTTPBodyPart</code> 实例然后调用每一个实例的 <code>read:maxLength:</code> 方法。</p>
<p>该方法内部通过 <code>AFHTTPBodyPart</code> 中定义的如下枚举类，分阶段将数据分布写进 buffer 中，每次写完一个阶段就会前往下一个阶段。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    AFEncapsulationBoundaryPhase = <span class="number">1</span>, <span class="comment">// 写初始分割符或者中间分割符的阶段</span></span><br><span class="line">    AFHeaderPhase                = <span class="number">2</span>, <span class="comment">// 写 headers 的阶段，包括 content-dispostion 等</span></span><br><span class="line">    AFBodyPhase                  = <span class="number">3</span>, <span class="comment">// 写 body 的阶段</span></span><br><span class="line">    AFFinalBoundaryPhase         = <span class="number">4</span>, <span class="comment">// 写结尾分割符的阶段，只有最后一个 body part 有这个阶段</span></span><br><span class="line">&#125; AFHTTPBodyPartReadPhase;</span><br></pre></td></tr></table></figure>

<p>第 1、2、4 阶段都是将字符串转换为 <code>NSData</code> 然后写入，2 阶段写入前，会讲所有的 headers 以 <code>key: value</code> 的形式拼接起来，并以换行符串联成一个整的字符串。</p>
<p>第 3 阶段则会根据当前 body 的类型（<code>NSData</code> <code>NSURL</code> 或者 <code>NSInputStream</code>）初始化一个 <code>NSInputStream</code> ，并从中读取。</p>
<p>以上就是整个 multipart request 生成和处理的过程。</p>
<p><code>AFHTTPRequestSerializer</code> 的两个子类 <code>AFJSONRequestSerializer</code> 和 <code>AFPropertyListRequestSerializer</code> 其父类的处理类似。不过分别将 <strong>Content-Type</strong> 设置为了 <strong>application&#x2F;json</strong> 和 <strong>application&#x2F;x-plist</strong> 。最后还是将对应格式的数据转换为了 <code>NSData</code> 设置到了 HTTP body 上。</p>
<h2 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h2><p>对 response 进行格式化的类相对而言比较简单，实际使用时主要使用 <code>AFHTTPResponseSerializer</code> 的特定格式的子类，如 <code>AFJSONResponseSerializer</code> , <code>AFXMLParserResponseSerializer</code> 等。</p>
<p>核心作用是通过以下方法将 response 解析成对象。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error;</span><br></pre></td></tr></table></figure>

<p>其主要过程首先是检查状态码看请求是否成功，然后检查一些 response 的参数是否齐全，如 <strong>Content-Type</strong> ，随后还会检查其中的 <strong>Content-Type</strong> 是否是对应的格式（如使用 <code>AFJSONResponseSerializer</code> 要求值为 <code>@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;</code> 中的一种）。最后使用对应的解析器将数据解析为对象。</p>
</div></article></div></main><footer><div class="paginator"><a class="next" href="../../../03/28/%F0%9F%8D%B1%20iOS%20%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%92%8C%20Masonry%20%E6%A1%86%E6%9E%B6/">NEXT</a></div><div class="copyright"><p>© 2019 - 2022 <a href="http://example.com">Shanyu Li</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p><p>Logo made by <a target="_blank" rel="noopener" href="https://www.flaticon.com/authors/freepik">Freepik</a> from <a target="_blank" rel="noopener" href="https://flaticon.com">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>