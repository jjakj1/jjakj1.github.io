<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ◻️ Widget in iOS · jjakj1's blog</title><meta name="description" content="◻️ Widget in iOS - Shanyu Li"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="../../../../maze.png"><link rel="stylesheet" href="../../../../css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="jjakj1's blog"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="atom.xml" title="jjakj1's blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="../../../../index.html"><img src="../../../../videogame.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="../../../../index.html" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/jjakj1" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="../../../../archives/" target="_self">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">◻️ Widget in iOS</h1><div class="post-info">Aug 3, 2022</div><div class="post-content"><p>在开发 iOS widget 的过程中对 widget 的使用范围和基本结构有了基本了解，同时在开发中也遇到了一些问题，本文对以上内容进行了总结</p>
<span id="more"></span>

<h2 id="Widget-介绍"><a href="#Widget-介绍" class="headerlink" title="Widget 介绍"></a>Widget 介绍</h2><p>Widget 不是一个 mini app，而是需要在某个时间（relevant）一下子提供相关的重要信息（glanceable）。同时能够自定义（Personalized）特别是需要支持多种大小。</p>
<p>Widget 内部通过 timeline 提供一系列在某个时间点进行展示的数据，当 timeline 结束后，系统会选择某个时间点对所有时间线进行刷新。也可以在 app 中使用 <code>WidgetCenter</code> 进行手动刷新。</p>
<p>Widget 定义上可以选择对如下选项的进行自我配置：</p>
<ul>
<li>Kind：static configuration；intent configuration（可以长按，选择对 widget 具体展示哪一项内容进行配置）</li>
<li>supported families：支持哪些大小的 widgets，默认会支持3种（small，medium，large）。</li>
</ul>
<p>新建一个 widget 的顺序为 File → New → Target → Widget Extension。</p>
<p>下面是一个新建 widget 的文件中结构：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Provider</span>: <span class="title class_">IntentTimelineProvider</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">placeholder</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">SimpleEntry</span> &#123;</span><br><span class="line">        <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), configuration: <span class="type">ConfigurationIntent</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getSnapshot</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">SimpleEntry</span>) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> entry <span class="operator">=</span> <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), configuration: configuration)</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getTimeline</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Timeline</span>&lt;<span class="type">Entry</span>&gt;) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">var</span> entries: [<span class="type">SimpleEntry</span>] <span class="operator">=</span> []</span><br><span class="line">		 <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> timeline <span class="operator">=</span> <span class="type">Timeline</span>(entries: entries, policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleEntry</span>: <span class="title class_">TimelineEntry</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> configuration: <span class="type">ConfigurationIntent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidgetEntryView</span> : <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entry: <span class="type">Provider</span>.<span class="type">Entry</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(entry.date, style: .time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidget</span>: <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> kind: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;TestWidget&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">WidgetConfiguration</span> &#123;</span><br><span class="line">        <span class="type">IntentConfiguration</span>(kind: kind, intent: <span class="type">ConfigurationIntent</span>.<span class="keyword">self</span>, provider: <span class="type">Provider</span>()) &#123; entry <span class="keyword">in</span></span><br><span class="line">            <span class="type">TestWidgetEntryView</span>(entry: entry)</span><br><span class="line">        &#125;</span><br><span class="line">        .configurationDisplayName(<span class="string">&quot;My Widget&quot;</span>)</span><br><span class="line">        .description(<span class="string">&quot;This is an example widget.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidget_Previews</span>: <span class="title class_">PreviewProvider</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TestWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), configuration: <span class="type">ConfigurationIntent</span>()))</span><br><span class="line">            .previewContext(<span class="type">WidgetPreviewContext</span>(family: .systemSmall))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面将对每一个部分进行解释。</p>
<p>首先 Widget 是通过 SwiftUI 框架进行编写的，<code>@main</code> 下面的部分都是一个 SwiftUI 文件的基础组成。<code>@main</code> 表示整个程序的入口，<code>TestWidget</code> 就是整个 Widget 展示的样式，下面的两个 modifier 可以用来更改一个 Widget 在小组件库（widget gallery）中的描述文字。下面的 preview 是在 Xcode 中预览的样式。</p>
<p>整个 Widget 就是一个 SwiftUI 里面的 View，上文中体现为一个 <code>TestWidgetEntryView</code> 。<code>body</code> 中就是其具体展示内容。</p>
<p>WidgetKit 通过 widget configuration 最后一个 <code>content</code> 的 block，来渲染实际的 widget，该 block 的唯一一个参数就是一个 <code>Provider.Entry</code> ，也就是我们上面定义的 <code>SimpleEntry</code> ，渲染 widget view 中另一些所需要的自定义数据也放在 entry 内部。</p>
<p>另外一个重要的就是 <code>TimelineProvider</code> ，widget 的更新数据源来自于一个 timeline。timeline 指出了在某个时间点上的数据，下面对 <code>TimelineProvider</code> 中的主要方法做解释。</p>
<h2 id="TimelineProvider"><a href="#TimelineProvider" class="headerlink" title="TimelineProvider"></a>TimelineProvider</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">placeholder</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">SimpleEntry</span></span><br></pre></td></tr></table></figure>

<p><code>placeholder</code> 就是作为一个数据没有加载出来的时候的临时样式。需要返回一个用于渲染 view 的 entry，但最终展示结果实际上是将 view 个部分模糊处理后的结果，同时，因为这里是将 entry 直接返回，如果 entry 中有自定义的属性，开发过程中最好直接使用一个本地数据，而不用去同步进行加载。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getSnapshot</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">SimpleEntry</span>) -&gt; ())</span><br></pre></td></tr></table></figure>

<p>Snapshot 是某一个 view 的视图，会在 widget gallery 中进行预览的时候被使用，因此只是一个时间点上的 view，<code>completion</code> 只需要传入一个 entry。由于这个地方使用 block 将 entry 传出，因此这里可以进行一些异步的操作，如从服务器请求数据等。</p>
<p><code>Context</code> 包括一些环境变量，如 <code>isPreview</code> 表示是否是在预览，可以在 widget gallery 进行预览时单独提供临时数据；<code>family</code> 表示当前的 widget 大小。</p>
<h3 id="timeline-和-widget-数据"><a href="#timeline-和-widget-数据" class="headerlink" title="timeline 和 widget 数据"></a>timeline 和 widget 数据</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getTimeline</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Timeline</span>&lt;<span class="type">Entry</span>&gt;) -&gt; ())</span><br></pre></td></tr></table></figure>

<p>Widget 的 time-line 提供了未来多个时间点上 widget 需要的<strong>数据源</strong>，也是当 widget 被放在屏幕上后的数据来源，每一个 timeline 中的 entry 代表了某一个时间点上的数据，这里可以看一下 block 中 <code>Timeline&lt;Entry&gt;</code> 的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Timeline</span>&lt;<span class="title class_">EntryType</span>&gt; <span class="title class_">where</span> <span class="title class_">EntryType</span> : <span class="title class_">TimelineEntry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> entries: [<span class="type">EntryType</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> policy: <span class="type">TimelineReloadPolicy</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Timeline 中包括了一整个数组的 entry，之前可以看到每个 entry 中包括了一个 date 属性，表示在未来的某个时间点上会被使用。每个 app 的整条时间线上的 widget 会被序列化放入磁盘中（很多时候包括几天），这使得系统能够同时运行多个 app widget 的时间线。</p>
<p>比如说我们希望 widget 展示一个等级，然后每一个小时等级加上1，在 entry 中加入 <code>level</code> 属性后，可以生成这样的时间线：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries: [<span class="type">SimpleEntry</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentDate <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">var</span> currentLevel <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">for</span> hourOffset <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> <span class="number">5</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> entryDate <span class="operator">=</span> <span class="type">Calendar</span>.current.date(byAdding: .hour, value: hourOffset, to: currentDate)<span class="operator">!</span></span><br><span class="line">  <span class="keyword">let</span> entry <span class="operator">=</span> <span class="type">SimpleEntry</span>(date: entryDate, configuration: configuration, level: currentLevel)</span><br><span class="line">  currentLevel <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">  entries.append(entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timeline <span class="operator">=</span> <span class="type">Timeline</span>(entries: entries, policy: .atEnd)</span><br><span class="line">completion(timeline)</span><br></pre></td></tr></table></figure>

<p>当然除了类似于上面这种全部数据从本地获取外，由于 timeline 使用的是一个 completion 作为回调，实际上也可以异步的对数据进行加载，如使用网络请求，在请求完数据后将拿到的数据放入 completion 中。</p>
<p>当然，也存在很多 widget 只需要即时的数据，此时提供当前能够拿到的 entry 就可以，即使只有一个。</p>
<p>获取了数据后考虑如何实际<strong>将数据进行展示</strong>，上面可以看到在建立的 widget 的 entry view 中实际上本身包含了一个 entry，这个 entry 也就是我们之前传入 timeline 中的数据源，后续只需要让实际展示的 view 直接从 entry 中获取数据即可。</p>
<p>展示数据后需要考虑的就是数据的刷新问题，widget 的数据由于全部来源于 timeline，每次刷新数据其实也就是重新生成 timeline 的过程，主要的刷新过程分为两种，一个是自动刷新（也就是交给系统进行），另一个就是手动刷新（在 app 内部进行刷新）。</p>
<p>首先介绍自动刷新，自动刷新需要配置 timeline 的另一个参数 <code>policy</code> ，代表了系统刷新 widget 的时机。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">TimelineReloadPolicy</span> : <span class="title class_">Equatable</span> &#123;</span><br><span class="line">	<span class="comment">/// 在 timeline 中的所有 entry 都被使用完后的某个时间点刷新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> atEnd: <span class="type">TimelineReloadPolicy</span></span><br><span class="line">	<span class="comment">/// 永远不进行被动刷新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> never: <span class="type">TimelineReloadPolicy</span></span><br><span class="line">	<span class="comment">/// 在某个时间点后刷新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">after</span>(<span class="keyword">_</span> <span class="params">date</span>: <span class="type">Date</span>) -&gt; <span class="type">TimelineReloadPolicy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意的是，这个时间点仅仅表示一种建议的最早时间点，实际过程中系统还会考虑诸如 app 活跃度，最近刷新时间等因素，而且每个 widget 在一天中都有一定的刷新次数限制。</p>
<p>手动刷新方法是在 app 内部通过 <code>WidgetCenter</code> 进行，<code>WidgetCenter</code> 提供了以下两个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WidgetCenter</span>.shared.reloadAllTimelines() <span class="comment">// 对 app 中所有的 widget 都生成一条新的时间线</span></span><br><span class="line"><span class="type">WidgetCenter</span>.shared.reloadTimelines(ofKind: <span class="string">&quot;TestWidget&quot;</span>) <span class="comment">// 对 app 中某个特定的 widget 刷新整条时间线，kind 对应的事 widget view 中的 kind 属性</span></span><br></pre></td></tr></table></figure>

<h2 id="开发中的其他问题"><a href="#开发中的其他问题" class="headerlink" title="开发中的其他问题"></a>开发中的其他问题</h2><h3 id="多个-widget-大小使用不同的-view"><a href="#多个-widget-大小使用不同的-view" class="headerlink" title="多个 widget 大小使用不同的 view"></a>多个 widget 大小使用不同的 view</h3><p>如果只是需要在不同大小的 widget 下使用不同的 view，只需要在那个 widget 的 view 中通过环境环境变量取得现在的 widget family，然后根据不同的 family 返回不同的 view。</p>
<p><code>@Environment</code> 就是去取得环境变量 <code>EnvironmentValues</code> 中的对应名称（key path）的属性值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.widgetFamily) <span class="keyword">var</span> family</span><br><span class="line"></span><br><span class="line"><span class="meta">@ViewBuilder</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> family &#123;</span><br><span class="line">	<span class="keyword">case</span> .systemSmall:</span><br><span class="line">		<span class="type">WidgetSmallView</span>()</span><br><span class="line">	<span class="keyword">case</span> .systemMedium:</span><br><span class="line">		<span class="type">WidgetMediumView</span>()</span><br><span class="line">	<span class="keyword">case</span> .systemLarge:</span><br><span class="line">		<span class="type">WidgetLargeView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>返回值 <code>some View</code> 指某特定一种实现了 <code>View</code> 协议的类，因为这里需要返回集中不同的 View 类，因此需要使用 <code>ViewBuilder</code> 将他们包装成一个 <code>TupleView</code> 保证返回值在各个条件分支下都相同。想进一步了解可以查看 SwiftUI 相关教程。</p>
</blockquote>
<p>另一种情况是对于同一个大小的也希望提供多种不同的 Widget。此时需要在 widget 文件中新建一个 <code>WidgetBundle</code> 类并将相关的所有 Widget 的 view 放在里面，同时也需要将代表入口的 <code>@main</code> 移到这个 bundle 上面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyWidgetBundle</span> : <span class="title class_">WidgetBundle</span> &#123;</span><br><span class="line">    <span class="meta">@WidgetBundleBuilder</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Widget</span> &#123;</span><br><span class="line">        <span class="type">FirstWidget</span>()</span><br><span class="line">		 <span class="type">SecondWidget</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="和主-App-的数据交互"><a href="#和主-App-的数据交互" class="headerlink" title="和主 App 的数据交互"></a>和主 App 的数据交互</h3><p>主 app 和 widget extension 不能直接进行数据的交互，只能间接的通过某些持久化的方式实现。首先需要对主 app 和 extension 进行设置，保证 app 和 widget extension 对应的 app group 是同一个。通讯可以使用 <code>UserDefaults</code> , <code>FileManager</code> 或者 CoreData 等方法进行同步。下面主要对 <code>UserDefault</code> 方法进行说明：</p>
<p>由于 extension 和主 app 使用的不是一个容器，因此只能将数据存放在同一个 app group 中，而不能直接放在 <code>UserDefaults.standard</code> 中。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/45607903/sharing-userdefaults-between-extensions">Share UserDefaults between extensions</a></p>
<p>下面是一个简单的类似于播放器的例子，我们希望主 app 在点击播放时，widget 上的 view 图标也会发生变化：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> userDefault <span class="operator">=</span> <span class="type">UserDefaults</span>(suiteName: <span class="string">&quot;group.com.lsy.testWidget&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span> &#123;</span><br><span class="line">            isPlaying.toggle()</span><br><span class="line">            userDefault.set(isPlaying, forKey: <span class="string">&quot;isPlaying&quot;</span>)</span><br><span class="line">            <span class="type">WidgetCenter</span>.shared.reloadAllTimelines()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: isPlaying <span class="operator">?</span> <span class="string">&quot;pause.circle&quot;</span> : <span class="string">&quot;play.circle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主 app 中的代码实际上就是更改了 isPlaying 的状态并对 widget 进行了刷新。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getTimeline</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Timeline</span>&lt;<span class="type">Entry</span>&gt;) -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> isPlaying <span class="operator">=</span> <span class="type">UserDefaults</span>(suiteName: <span class="string">&quot;group.com.lsy.testWidget&quot;</span>)<span class="operator">!</span>.bool(forKey: <span class="string">&quot;isPlaying&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> entries: [<span class="type">SimpleEntry</span>] <span class="operator">=</span> [<span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), configuration: configuration, isPlaying: isPlaying)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> timeline <span class="operator">=</span> <span class="type">Timeline</span>(entries: entries, policy: .atEnd)</span><br><span class="line">    completion(timeline)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidgetEntryView</span> : <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entry: <span class="type">Provider</span>.<span class="type">Entry</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: entry.isPlaying <span class="operator">?</span> <span class="string">&quot;pause.circle&quot;</span> : <span class="string">&quot;play.circle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Widget 在 timeline 中读取了值，并根据是否在播放决定展示的图标。</p>
<p>也可以通过 <a href="craftdocs://open?blockId=ACCB5181-F6BC-41AA-9D81-1E0EA8C27D13&spaceId=ea081854-0d6c-dace-b07b-5007ad758cc9"><code>AppStorage 直接在 view 中进行读取。</code></a></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidgetEntryView</span> : <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entry: <span class="type">Provider</span>.<span class="type">Entry</span></span><br><span class="line">    <span class="meta">@AppStorage</span>(<span class="string">&quot;isPlaying&quot;</span>, store: <span class="type">UserDefaults</span>(suiteName: <span class="string">&quot;group.com.lsy.testWidget&quot;</span>)) <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: isPlaying <span class="operator">?</span> <span class="string">&quot;pause.circle&quot;</span> : <span class="string">&quot;play.circle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但要注意的是，由于 widget 是一个静态的 view，<code>@AppStorage</code> 值的变化不会响应出来，还是只能通过主 app 手动调用 reload。</p>
<h3 id="跳转主-App"><a href="#跳转主-App" class="headerlink" title="跳转主 App"></a>跳转主 App</h3><p>widget 主要的理念就是展示一些静态的信息，因此不能够直接操控主 app 的行为，所有内容需要跳转到主 app 进行消费。</p>
<p>对于 widget 上单个 view 的跳转使用 SwiftUI 的 <code>Link</code> 完成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Link</span>(destination: <span class="type">URL</span>(<span class="operator">...</span>)) &#123;</span><br><span class="line">	<span class="type">SingleView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望整个 widget 进行导航跳转，使用 <code>.widgetURL</code> 的修改器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WidgetView</span>()</span><br><span class="line">	.widgetURL(<span class="type">URL</span>(<span class="operator">...</span>))</span><br></pre></td></tr></table></figure>

<p>两者都使用一个 <code>URL</code> 作为唯一的参数。</p>
<h3 id="异步的图片加载"><a href="#异步的图片加载" class="headerlink" title="异步的图片加载"></a>异步的图片加载</h3><p>对于 widget 上的图片，要注意的是 widget 是一个静态 view，通过 timeline 中提供的 entry 进行渲染并展示后不会再默认进行后台任务，因此，如果有一个图片要通过 URL 进行获取，需要在提供的 entry 前就加载完成。</p>
<p>iOS 中可以使用 <code>DispatchGroup</code> 来保证所有图片被加载完成：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageFromURL</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> urlString: <span class="type">URL</span></span><br><span class="line">	<span class="keyword">var</span> image: <span class="type">UIImage</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">ImageFromURL</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fetchAllImages</span>(<span class="params">completion</span>:<span class="keyword">@escaping</span> ([<span class="type">ImageFromURL</span>]) -&gt;()) &#123;</span><br><span class="line">        <span class="keyword">let</span> dispatchGroup <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">        <span class="keyword">var</span> images: [<span class="type">ImageFromURL</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">self</span>.forEach &#123; element <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: element.urlString) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            dispatchGroup.enter()</span><br><span class="line">            <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> data, <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: data) &#123;</span><br><span class="line">                    <span class="keyword">var</span> element <span class="operator">=</span> element</span><br><span class="line">                    element.image <span class="operator">=</span> image</span><br><span class="line">                    images.append(element)</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchGroup.leave()</span><br><span class="line">            &#125;.resume()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatchGroup.notify(queue: .main) &#123;</span><br><span class="line">            completion(images)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个方法是让服务端第一次就直接下发图片的 base64 data。</p>
<h3 id="ProgressView"><a href="#ProgressView" class="headerlink" title="ProgressView"></a>ProgressView</h3><p><code>ProgressView</code> 不能直接用于 Widget，如果想要实现一个进度条的效果，可以自己使用 <code>Geometry</code> 和 <code>Path</code> 实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomProgressView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> progress: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">let</span> total: <span class="type">Double</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">GeometryReader</span> &#123; geometry <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> frame <span class="operator">=</span> geometry.frame(in: .local)</span><br><span class="line">            <span class="type">Path</span> &#123; path <span class="keyword">in</span></span><br><span class="line">                path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: frame.minY))</span><br><span class="line">                path.addLines(</span><br><span class="line">                    [<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: frame.minY),</span><br><span class="line">                     <span class="type">CGPoint</span>(x: frame.maxX, y: frame.minY),</span><br><span class="line">                     <span class="type">CGPoint</span>(x: frame.maxX, y: frame.maxY),</span><br><span class="line">                     <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: frame.maxY)])</span><br><span class="line">            &#125;.fill(.gray)</span><br><span class="line">                .cornerRadius(frame.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">            <span class="type">Path</span> &#123; path <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">let</span> width <span class="operator">=</span> frame.width <span class="operator">*</span> progress <span class="operator">/</span> total</span><br><span class="line">                path.move(to: <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: frame.minY))</span><br><span class="line">                path.addLines(</span><br><span class="line">                    [<span class="type">CGPoint</span>(x: <span class="number">0</span>, y: frame.minY),</span><br><span class="line">                     <span class="type">CGPoint</span>(x: width, y: frame.minY),</span><br><span class="line">                     <span class="type">CGPoint</span>(x: width, y: frame.maxY),</span><br><span class="line">                     <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: frame.maxY)]</span><br><span class="line">                )</span><br><span class="line">            &#125;.fill(.blue)</span><br><span class="line">                .cornerRadius(frame.height <span class="operator">/</span> <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a class="next" href="../../../05/29/%F0%9F%8C%90%20AFNetworking%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">NEXT</a></div><div class="copyright"><p>© 2019 - 2022 <a href="http://example.com">Shanyu Li</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p><p>Logo made by <a target="_blank" rel="noopener" href="https://www.flaticon.com/authors/freepik">Freepik</a> from <a target="_blank" rel="noopener" href="https://flaticon.com">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>