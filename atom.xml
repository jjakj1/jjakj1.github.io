<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jjakj1&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-03T15:26:04.682Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Shanyu Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>◻️ Widget in iOS</title>
    <link href="http://example.com/2022/08/03/%E2%97%BB%EF%B8%8F%20Widget%20in%20iOS/"/>
    <id>http://example.com/2022/08/03/%E2%97%BB%EF%B8%8F%20Widget%20in%20iOS/</id>
    <published>2022-08-03T14:30:00.000Z</published>
    <updated>2022-08-03T15:26:04.682Z</updated>
    
    <content type="html"><![CDATA[<p>在开发 iOS widget 的过程中对 widget 的使用范围和基本结构有了基本了解，同时在开发中也遇到了一些问题，本文对以上内容进行了总结</p><span id="more"></span><h2 id="Widget-介绍"><a href="#Widget-介绍" class="headerlink" title="Widget 介绍"></a>Widget 介绍</h2><p>Widget 不是一个 mini app，而是需要在某个时间（relevant）一下子提供相关的重要信息（glanceable）。同时能够自定义（Personalized）特别是需要支持多种大小。</p><p>Widget 内部通过 timeline 提供一系列在某个时间点进行展示的数据，当 timeline 结束后，系统会选择某个时间点对所有时间线进行刷新。也可以在 app 中使用 <code>WidgetCenter</code> 进行手动刷新。</p><p>Widget 定义上可以选择对如下选项的进行自我配置：</p><ul><li>Kind：static configuration；intent configuration（可以长按，选择对 widget 具体展示哪一项内容进行配置）</li><li>supported families：支持哪些大小的 widgets，默认会支持3种（small，medium，large）。</li></ul><p>Widget 的唯一交互就是通过提供一个 scheme URL 直接点击并进入某个深入的 app 页面。这里提供了两种 API，一种是点击整个 widget 进行跳转的 <code>.widgetURL</code> ，另一种是针对其中某个 view 进行跳转的 SwiftUI <code>Link</code> 。</p><p>新建一个 widget 的顺序为 File → New → Target → Widget Extension。</p><p>下面是一个新建 widget 的文件中结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Provider</span>: <span class="title class_">IntentTimelineProvider</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">placeholder</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">SimpleEntry</span> &#123;</span><br><span class="line">        <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), configuration: <span class="type">ConfigurationIntent</span>())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getSnapshot</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">SimpleEntry</span>) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">let</span> entry <span class="operator">=</span> <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), configuration: configuration)</span><br><span class="line">        completion(entry)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">getTimeline</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Timeline</span>&lt;<span class="type">Entry</span>&gt;) -&gt; ()) &#123;</span><br><span class="line">        <span class="keyword">var</span> entries: [<span class="type">SimpleEntry</span>] <span class="operator">=</span> []</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">let</span> timeline <span class="operator">=</span> <span class="type">Timeline</span>(entries: entries, policy: .atEnd)</span><br><span class="line">        completion(timeline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SimpleEntry</span>: <span class="title class_">TimelineEntry</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> configuration: <span class="type">ConfigurationIntent</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidgetEntryView</span> : <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entry: <span class="type">Provider</span>.<span class="type">Entry</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(entry.date, style: .time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidget</span>: <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> kind: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;TestWidget&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">WidgetConfiguration</span> &#123;</span><br><span class="line">        <span class="type">IntentConfiguration</span>(kind: kind, intent: <span class="type">ConfigurationIntent</span>.<span class="keyword">self</span>, provider: <span class="type">Provider</span>()) &#123; entry <span class="keyword">in</span></span><br><span class="line">            <span class="type">TestWidgetEntryView</span>(entry: entry)</span><br><span class="line">        &#125;</span><br><span class="line">        .configurationDisplayName(<span class="string">&quot;My Widget&quot;</span>)</span><br><span class="line">        .description(<span class="string">&quot;This is an example widget.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidget_Previews</span>: <span class="title class_">PreviewProvider</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> previews: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">TestWidgetEntryView</span>(entry: <span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), configuration: <span class="type">ConfigurationIntent</span>()))</span><br><span class="line">            .previewContext(<span class="type">WidgetPreviewContext</span>(family: .systemSmall))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将对每一个部分进行解释。</p><p>首先 Widget 是通过 SwiftUI 框架进行编写的，<code>@main</code> 下面的部分都是一个 SwiftUI 文件的基础组成。<code>@main</code> 表示整个程序的入口，<code>TestWidget</code> 就是整个 Widget 展示的样式，下面的两个 modifier 可以用来更改一个 Widget 在小组件库（widget gallery）中的描述文字。下面的 preview 是在 Xcode 中预览的样式。</p><p>整个 Widget 就是一个 SwiftUI 里面的 View，上文中体现为一个 <code>TestWidgetEntryView</code> 。<code>body</code> 中就是其具体展示内容。</p><p>WidgetKit 通过 widget configuration 最后一个 <code>content</code> 的 block，来渲染实际的 widget，该 block 的唯一一个参数就是一个 <code>Provider.Entry</code> ，也就是我们上面定义的 <code>SimpleEntry</code> ，渲染 widget view 中另一些所需要的自定义数据也放在 entry 内部。</p><p>另外一个重要的就是 <code>TimelineProvider</code> ，widget 的更新数据源来自于一个 timeline。timeline 指出了在某个时间点上的数据，下面对 <code>TimelineProvider</code> 中的主要方法做解释。</p><h2 id="TimelineProvider"><a href="#TimelineProvider" class="headerlink" title="TimelineProvider"></a>TimelineProvider</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">placeholder</span>(<span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>) -&gt; <span class="type">SimpleEntry</span></span><br></pre></td></tr></table></figure><p><code>placeholder</code> 就是作为一个数据没有加载出来的时候的临时样式。需要返回一个用于渲染 view 的 entry，但最终展示结果实际上是将 view 个部分模糊处理后的结果，同时，因为这里是将 entry 直接返回，如果 entry 中有自定义的属性，开发过程中最好直接使用一个本地数据，而不用去同步进行加载。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getSnapshot</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">SimpleEntry</span>) -&gt; ())</span><br></pre></td></tr></table></figure><p>Snapshot 是某一个 view 的视图，会在 widget gallery 中进行预览的时候被使用，因此只是一个时间点上的 view，<code>completion</code> 只需要传入一个 entry。由于这个地方使用 block 将 entry 传出，因此这里可以进行一些异步的操作，如从服务器请求数据等。</p><p><code>Context</code> 包括一些环境变量，如 <code>isPreview</code> 表示是否是在预览，可以在 widget gallery 进行预览时单独提供临时数据；<code>family</code> 表示当前的 widget 大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getTimeline</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Timeline</span>&lt;<span class="type">Entry</span>&gt;) -&gt; ())</span><br></pre></td></tr></table></figure><p>Widget 的 time-line 提供了未来多个时间点上 widget 需要的数据源，这里可以看一下 block 中 <code>Timeline&lt;Entry&gt;</code> 的定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">Timeline</span>&lt;<span class="title class_">EntryType</span>&gt; <span class="title class_">where</span> <span class="title class_">EntryType</span> : <span class="title class_">TimelineEntry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> entries: [<span class="type">EntryType</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> policy: <span class="type">TimelineReloadPolicy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Timeline 中包括了一整个数组的 entry，之前可以看到每个 entry 中包括了一个 date 属性，表示在未来的某个时间点上会被使用。每个 app 的整条时间线上的 widget 会被序列化放入磁盘中（很多时候包括几天），这使得系统能够同时运行多个 app widget 的时间线。</p><p>比如说我们希望 widget 展示一个等级，然后每一个小时等级加上1，在 entry 中加入 <code>level</code> 属性后，可以生成这样的时间线：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries: [<span class="type">SimpleEntry</span>] <span class="operator">=</span> []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentDate <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">var</span> currentLevel <span class="operator">=</span> <span class="type">Date</span>()</span><br><span class="line"><span class="keyword">for</span> hourOffset <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> <span class="number">5</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> entryDate <span class="operator">=</span> <span class="type">Calendar</span>.current.date(byAdding: .hour, value: hourOffset, to: currentDate)<span class="operator">!</span></span><br><span class="line">  <span class="keyword">let</span> entry <span class="operator">=</span> <span class="type">SimpleEntry</span>(date: entryDate, configuration: configuration, level: currentLevel)</span><br><span class="line">  currentLevel <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">  entries.append(entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timeline <span class="operator">=</span> <span class="type">Timeline</span>(entries: entries, policy: .atEnd)</span><br><span class="line">completion(timeline)</span><br></pre></td></tr></table></figure><p>当然，也存在很多需要 widget 只需要即时的数据，此时提供当前能够拿到的 entry 就可以，即使只有一个。后续我们将对 widget 如何进行刷新进行进一步介绍。</p><p>timeline 的另一个参数是 <code>policy</code> ，代表了系统刷新 widget 的时机。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">TimelineReloadPolicy</span> : <span class="title class_">Equatable</span> &#123;</span><br><span class="line"><span class="comment">/// 在 timeline 中的所有 entry 都被使用完后的某个时间点刷新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> atEnd: <span class="type">TimelineReloadPolicy</span></span><br><span class="line"><span class="comment">/// 永远不进行被动刷新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> never: <span class="type">TimelineReloadPolicy</span></span><br><span class="line"><span class="comment">/// 在某个时间点后刷新</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">after</span>(<span class="keyword">_</span> <span class="params">date</span>: <span class="type">Date</span>) -&gt; <span class="type">TimelineReloadPolicy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，这个时间点仅仅表示一种建议的最早时间点，实际过程中系统还会考虑诸如 app 活跃度，最近刷新时间等因素，而且每个 widget 在一天中都有一定的刷新次数限制。</p><p>另一种主动方法是在 app 内部通过 <code>WidgetCenter</code> 今天刷新，<code>WidgetCenter</code> :</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WidgetCenter</span>.shared.reloadAllTimelines() <span class="comment">// 对 app 中所有的 widget 都生成一条新的时间线</span></span><br><span class="line"><span class="type">WidgetCenter</span>.shared.reloadTimelines(ofKind: <span class="string">&quot;TestWidget&quot;</span>) <span class="comment">// 对 app 中某个特定的 widget 刷新整条时间线，kind 对应的事 widget view 中的 kind 属性</span></span><br></pre></td></tr></table></figure><h2 id="开发中的其他问题"><a href="#开发中的其他问题" class="headerlink" title="开发中的其他问题"></a>开发中的其他问题</h2><h3 id="多个-widget-大小使用不同的-view"><a href="#多个-widget-大小使用不同的-view" class="headerlink" title="多个 widget 大小使用不同的 view"></a>多个 widget 大小使用不同的 view</h3><p>如果只是需要在不同大小的 widget 下使用不同的 view，只需要在那个 widget 的 view 中通过环境环境变量取得现在的 widget family，然后根据不同的 family 返回不同的 view。</p><p><code>@Environment</code> 就是去取得环境变量 <code>EnvironmentValues</code> 中的对应名称（key path）的属性值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.widgetFamily) <span class="keyword">var</span> family</span><br><span class="line"></span><br><span class="line"><span class="meta">@ViewBuilder</span></span><br><span class="line"><span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> family &#123;</span><br><span class="line"><span class="keyword">case</span> .systemSmall:</span><br><span class="line"><span class="type">WidgetSmallView</span>()</span><br><span class="line"><span class="keyword">case</span> .systemMedium:</span><br><span class="line"><span class="type">WidgetMediumView</span>()</span><br><span class="line"><span class="keyword">case</span> .systemLarge:</span><br><span class="line"><span class="type">WidgetLargeView</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>返回值 <code>some View</code> 指某特定一种实现了 <code>View</code> 协议的类，因为这里需要返回集中不同的 View 类，因此需要使用 <code>ViewBuilder</code> 将他们包装成一个 <code>TupleView</code> 保证返回值在各个条件分支下都相同。想进一步了解可以查看 SwiftUI 相关教程。</p></blockquote><p>另一种情况是对于同一个大小的也希望提供多种不同的 Widget。此时需要在 widget 文件中新建一个 <code>WidgetBundle</code> 类并将相关的所有 Widget 的 view 放在里面，同时也需要将代表入口的 <code>@main</code> 移到这个 bundle 上面。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyWidgetBundle</span> : <span class="title class_">WidgetBundle</span> &#123;</span><br><span class="line">    <span class="meta">@WidgetBundleBuilder</span></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Widget</span> &#123;</span><br><span class="line">        <span class="type">FirstWidget</span>()</span><br><span class="line"> <span class="type">SecondWidget</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和主-App-的数据交互"><a href="#和主-App-的数据交互" class="headerlink" title="和主 App 的数据交互"></a>和主 App 的数据交互</h3><p>首先都进行设置，保证 app 和 widget extension 对应的 app group 是同一个。通讯可以使用 <code>UserDefaults</code> , <code>FileManager</code> 或者 CoreData 的方法进行同步，三者其实都是持久化数据的方法。下面主要对 <code>UserDefault</code> 方法进行说明：</p><p>由于 extension 和主 app 使用的不是一个容器，因此只能将数据存放在同一个 app group 中，而不能直接放在 <code>UserDefaults.standard</code> 中。<a href="https://stackoverflow.com/questions/45607903/sharing-userdefaults-between-extensions">Share UserDefaults between extensions</a></p><p>下面是一个简单的类似于播放器的例子，我们希望主 app 在点击播放时，widget 上的 view 图标也会发生变化：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> userDefault <span class="operator">=</span> <span class="type">UserDefaults</span>(suiteName: <span class="string">&quot;group.com.lsy.testWidget&quot;</span>)<span class="operator">!</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span> &#123;</span><br><span class="line">            isPlaying.toggle()</span><br><span class="line">            userDefault.set(isPlaying, forKey: <span class="string">&quot;isPlaying&quot;</span>)</span><br><span class="line">            <span class="type">WidgetCenter</span>.shared.reloadAllTimelines()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: isPlaying <span class="operator">?</span> <span class="string">&quot;pause.circle&quot;</span> : <span class="string">&quot;play.circle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主 app 中的代码实际上就是更改了 isPlaying 的状态并对 widget 进行了刷新。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getTimeline</span>(<span class="params">for</span> <span class="params">configuration</span>: <span class="type">ConfigurationIntent</span>, <span class="params">in</span> <span class="params">context</span>: <span class="type">Context</span>, <span class="params">completion</span>: <span class="keyword">@escaping</span> (<span class="type">Timeline</span>&lt;<span class="type">Entry</span>&gt;) -&gt; ()) &#123;</span><br><span class="line">    <span class="keyword">let</span> isPlaying <span class="operator">=</span> <span class="type">UserDefaults</span>(suiteName: <span class="string">&quot;group.com.lsy.testWidget&quot;</span>)<span class="operator">!</span>.bool(forKey: <span class="string">&quot;isPlaying&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> entries: [<span class="type">SimpleEntry</span>] <span class="operator">=</span> [<span class="type">SimpleEntry</span>(date: <span class="type">Date</span>(), configuration: configuration, isPlaying: isPlaying)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> timeline <span class="operator">=</span> <span class="type">Timeline</span>(entries: entries, policy: .atEnd)</span><br><span class="line">    completion(timeline)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidgetEntryView</span> : <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entry: <span class="type">Provider</span>.<span class="type">Entry</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: entry.isPlaying <span class="operator">?</span> <span class="string">&quot;pause.circle&quot;</span> : <span class="string">&quot;play.circle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Widget 在 timeline 中读取了值，并根据是否在播放决定展示的图标。</p><p>也可以通过 <a href="craftdocs://open?blockId=ACCB5181-F6BC-41AA-9D81-1E0EA8C27D13&spaceId=ea081854-0d6c-dace-b07b-5007ad758cc9"><code>AppStorage 直接在 view 中进行读取。</code></a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TestWidgetEntryView</span> : <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> entry: <span class="type">Provider</span>.<span class="type">Entry</span></span><br><span class="line">    <span class="meta">@AppStorage</span>(<span class="string">&quot;isPlaying&quot;</span>, store: <span class="type">UserDefaults</span>(suiteName: <span class="string">&quot;group.com.lsy.testWidget&quot;</span>)) <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: isPlaying <span class="operator">?</span> <span class="string">&quot;pause.circle&quot;</span> : <span class="string">&quot;play.circle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但要注意的是，由于 widget 是一个静态的 view，<code>@AppStorage</code> 值的变化不会响应出来，还是只能通过主 app 手动调用 reload。</p><h3 id="异步的图片加载"><a href="#异步的图片加载" class="headerlink" title="异步的图片加载"></a>异步的图片加载</h3><p>对于 widget 上的图片，要注意的是 widget 是一个静态 view，通过 timeline 中提供的 entry 进行渲染并展示后不会再默认进行后台任务，因此，如果有一个图片要通过 URL 进行获取，需要在提供的 entry 前就加载完成。</p><p>iOS 中可以使用 <code>DispatchGroup</code> 来保证所有图片被加载完成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImageFromURL</span> &#123;</span><br><span class="line"><span class="keyword">let</span> urlString: <span class="type">URL</span></span><br><span class="line"><span class="keyword">var</span> image: <span class="type">UIImage</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">Array</span> <span class="title class_">where</span> <span class="title class_">Element</span> == <span class="title class_">ImageFromURL</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">fetchAllImages</span>(<span class="params">completion</span>:<span class="keyword">@escaping</span> ([<span class="type">ImageFromURL</span>]) -&gt;()) &#123;</span><br><span class="line">        <span class="keyword">let</span> dispatchGroup <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line">        <span class="keyword">var</span> images: [<span class="type">ImageFromURL</span>] <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">self</span>.forEach &#123; element <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> url <span class="operator">=</span> <span class="type">URL</span>(string: element.urlString) <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            dispatchGroup.enter()</span><br><span class="line">            <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> data <span class="operator">=</span> data, <span class="keyword">let</span> image <span class="operator">=</span> <span class="type">UIImage</span>(data: data) &#123;</span><br><span class="line">                    <span class="keyword">var</span> element <span class="operator">=</span> element</span><br><span class="line">                    element.image <span class="operator">=</span> image</span><br><span class="line">                    images.append(element)</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchGroup.leave()</span><br><span class="line">            &#125;.resume()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatchGroup.notify(queue: .main) &#123;</span><br><span class="line">            completion(images)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法是让服务端第一次就直接下发图片的 base64 data。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开发 iOS widget 的过程中对 widget 的使用范围和基本结构有了基本了解，同时在开发中也遇到了一些问题，本文对以上内容进行了总结&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>🌐 AFNetworking 源码分析</title>
    <link href="http://example.com/2022/05/29/%F0%9F%8C%90%20AFNetworking%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/05/29/%F0%9F%8C%90%20AFNetworking%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-05-29T13:07:00.000Z</published>
    <updated>2022-05-29T13:09:04.468Z</updated>
    
    <content type="html"><![CDATA[<p>研究了 AFNetworking 网络框架的主要结构和方法，对其内部如何建立一个请求，做了哪些额外工作，特别是如何发送一个 multipart request 请求进行了较为深入的分析。</p><span id="more"></span><p>AFNetworking 作为 iOS 最著名的网络框架之一，对官方 <code>NSURLSession</code> 一系列 API 进行了封装，提供了大量更方便使用的接口。</p><p>对于这样一种框架，我认为想要了解其相对于原生 API 的优势，首先就需要对两者 API 的使用有一定的了解，在阅读其源码前，我写了一个 Demo。Demo 使用的网络请求类中同时提供接口相同的、但内部分别由原生 API 和 AFNetworking API 实现，以此来感受双方 API 的差异性。详情可以参考 <a href="https://github.com/jjakj1/AFNetworkingDemo">Github</a> 中的 <code>NetworkingDataManager</code> 类。（其实最开始进行对比的时候，我没有特别感受到 AFNetworking 相对于原生 API 方便很多，可能更多细节在于对于错误情况的处理和数据的转换上，这个需要等阅读源码后才能得出结论）</p><h2 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h2><p><code>AFURLSessionManger</code> 作为调用 AFNetworking 所提供的 API 的类，大致结构如下：</p><p><img src="https://res.craft.do/user/full/ea081854-0d6c-dace-b07b-5007ad758cc9/doc/BAA570CA-8DD7-4D68-9E22-C44B50358FF0/BE908F8C-99D6-49B7-A074-E0B057FB241D_2/VaA0yRAbWDxG6ohe6papFFzxtYxxrh4ZyFVBBg71ynQz/AFURLSessionManager.png" alt="AFURLSessionManager.png"></p><p>其中 <code>AFURLSessionManager</code> 自身实现了几个官方的 Delegate，并提供了一系列的 block 作为属性，让外界去设置。内部私有了一个 <code>AFURLSessionManagerTaskDelegate</code> 类，其实现了除 <code>NSURLSessionDelegate</code> 之外其他三个 Delegate 的大部分方法。</p><p><code>AFURLSessionManager</code> 内部最重要的结构是一个字典，其使用创建的各个 <code>URLSessionTask</code> 的 identifier 作为键，并将一个 <code>AFURLSessionManagerTaskDelegate</code> 对象作为值，该对象会在每次创建一个新的 task 时被同时创建，并将一些为了实现三种代理中方法所需要的 block 传入进去。Delegate 最终会在 <code>URLSession:task:didCompleteWithError:</code> 中被释放</p><p><code>AFURLSessionManager</code> 处理一个代理方法最普遍的行为实际上分为两种情况：</p><ul><li><code>AFURLSessionManagerTaskDelegate</code> 如果也实现了那个代理方法，就会从字典里找到当前 task 对应的 Delegate 并调用 Delegate 里面的对应代理方法。</li><li>如果 <code>AFURLSessionManagerTaskDelegate</code> 没有实现该方法，就判断对应的 block 是否被设置，如果进行了设置，则调用该 block。</li></ul><p>另外内部还保存并默认设置了以下属性来对内部的状态和数据进行处理，后续也会进行分析。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer; <span class="comment">// default is AFJSONResponseSerializer</span></span><br></pre></td></tr></table></figure><h2 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h2><p>继承了 <code>AFURLSessionManager</code> ，内部基本一致，添加了 <code>AFHTTPRequestSerializer</code> 属性。并默认提供了一个 <code>AFHTTPRequestSerializer</code> 作为其默认值。同时对于 <code>requestSerializer</code> 属性的定义也有所变化，但默认赋值还是 <code>AFJSONResponseSerializer</code> 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In AFURLSessionManager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> &lt;AFURLResponseSerialization&gt; responseSerializer;</span><br><span class="line"><span class="comment">// In AFHTTPSessionManager</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer</span><br></pre></td></tr></table></figure><p>添加了一个 <code>baseURL</code> 属性，方便在之后的请求中，只用提供剩下的文件路径。</p><p>主要提供了一些带有 HTTP method （GET、POST 等）的 data task 相关方法，其内部实现基本都是直接调用了下面的这个私有方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                         headers:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *)headers</span><br><span class="line">                                  uploadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                                downloadProgress:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                         success:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *task, <span class="type">id</span> _Nullable responseObject))success</span><br><span class="line">                                         failure:(<span class="keyword">nullable</span> <span class="type">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> *error))failure;</span><br></pre></td></tr></table></figure><p>该方法中利用 <code>AFHTTPRequestSerializer</code> 来将 <code>method</code> <code>URLString</code> 和 <code>paramters</code> 合并成一个 <code>NSMutableURLRequest</code> 并遍历所有的 <code>headers</code> 中的键值对。来使用 <code>setValue: forHTTPHeaderField:</code> 方法更改 Header 中的值，最后调用父类中创建 data task 的方法。</p><h2 id="AFHTTPRequestSerializer"><a href="#AFHTTPRequestSerializer" class="headerlink" title="AFHTTPRequestSerializer"></a>AFHTTPRequestSerializer</h2><p><code>AFHTTPRequestSerializer</code> 实现了协议 <code>AFURLRequestSerialization</code> 。该协议提供了以下的方法，而 <code>AFHTTPRequestSerializer</code> 也就是通过调用这个方法来将一个 request 和 parameters 进行序列化，从而生成一个新的 request，这个方法的详细实现将在后续讲述。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                        withParameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                                 error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br></pre></td></tr></table></figure><p><code>AFHTTPRequestSerializer</code> 的初始化过程主要干了 3 件事：</p><ol><li>通过 <code>[NSLocale preferredLanguages]</code> 从设置从取出本机偏好的语言顺序，并使用此信息设置 HTTP header 中的 <strong>Accept-Language</strong> 。</li><li>通过 bundle 或 device 的信息设置 HTTP header 中的 <strong>User-Agent</strong> 。</li><li>使用 KVO 将自身作为监听者，监听内部一些其他属性的变动。如 <code>allowsCellularAccess</code> <code>HTTPShouldHandleCookies</code> 等，这些也都是 <code>NSURLRequest</code> 的一些属性。属性会在变动时，被加入内部的 <code>mutableObservedChangedKeyPaths</code> 属性中，该属性是一个 <code>NSMutableSet</code> 。</li></ol><p>除此之外，该类还提供了一些用于设置 HTTP header 的方法，如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setValue:(<span class="built_in">NSString</span> *)value</span><br><span class="line">forHTTPHeaderField:(<span class="built_in">NSString</span> *)field;</span><br></pre></td></tr></table></figure><p>被设置 value 和 field 都会以键值对的形式存放在内部的一个 <code>NSMutableDictionary</code> 中，直到最后调用上面的序列化方法时才会被集体使用，通过调用 <code>setValue:forHTTPHeaderField:</code> 方法设置最终 request 的 HTTP header Field。</p><p>一个细节是，为了保证在 set header 时的线程安全，在设置时内部使用了 <code>dispatch_barrier_sync</code> 。</p><h3 id="非-multipart-request"><a href="#非-multipart-request" class="headerlink" title="非 multipart request"></a>非 multipart request</h3><p><code>AFHTTPRequestSerializer</code> 另外的核心 API 可以分为生成 multipart request 部分和非 multipart request 两个部分来看。首先介绍非 multipart request 部分。其接口如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                          URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                         parameters:(<span class="keyword">nullable</span> <span class="type">id</span>)parameters</span><br><span class="line">                                              error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br></pre></td></tr></table></figure><p>调用该方法时，其内部主要做了三件事：</p><ol><li>通过 URLString 生成一个 URLRequest，并将该请求的 method 设置为指定的 method。</li><li>遍历更改过的属性列表 <code>mutableObservedChangedKeyPaths</code> ，使用 <code>setValue:forKey:</code> 方法去改变 request 中对应属性的值。</li><li>调用上面的序列化方法，传入生成的这个 request 以及参数中的 parameters 和 error。</li></ol><p>接下来我们看看序列化方法内部过程。其方法内部大概步骤如下：</p><ol><li><code>mutableCopy</code> 传入的 request，并将 serializer 内部之前设置的 headers 通过 <code>setValue:forHTTPField:</code> 设置到 request 上。</li><li>如果传入的 parameters 不为空，首先看外部有没有指定一个 block 来处理 parameter（通过一个 property 设置），有就通过这个 block 处理 parameters，如果没有就将它们转换为 <code>key=value</code> 的形式并用 <code>&amp;</code> 串联成一个字符串，作为 query。</li><li>最后如果请求方法是 GET, HEAD, DELETE 中的一种，就直接吧 query 拼接在 request 的 URL 上。如果不是而且 request 没有 <strong>Content-Type</strong> 就将其设置为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST">application&#x2F;x-www-form-urlencoded</a>，然后把 query 转换为 <code>NSData</code> 设置到 HTTP 的 body 上。</li><li>返回上面处理好的 request。</li></ol><h3 id="Multipart-request"><a href="#Multipart-request" class="headerlink" title="Multipart request"></a>Multipart request</h3><p>首先我们要明白 multipart request 结构是什么样的。使用 Postman 发送网络请求可以指定 body 格式为 form-data（method 类型不能是 GET 和 HEAD），表示以表单形式提交，表单数据将会被处理成一条请求，此时发送的就是一个 multipart request。同时发送这类请求我们可以指定 value 是一个文件。</p><p><img src="https://res.craft.do/user/full/ea081854-0d6c-dace-b07b-5007ad758cc9/doc/BAA570CA-8DD7-4D68-9E22-C44B50358FF0/A7762D1C-23C0-4C22-BDB5-1B57A4D45E02_2/dxyIZJfqN7r5cBrqTGtYxYWPNlu8HmnqvBvCB3LmOngz/Image.png" alt="Image.png"></p><p>我们接下来通过实际发送的 HTTP 包来看一下 multipart request 的具体格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">POST /post HTTP/1.1</span><br><span class="line">User-Agent: PostmanRuntime/7.29.0</span><br><span class="line">Accept: */*</span><br><span class="line">Postman-Token: d3f08e2a-5e01-4f6a-9279-2689018f30eb</span><br><span class="line">Host: httpbin.org</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Type: multipart/form-data; boundary=--------------------------833910809558491007284810</span><br><span class="line">Content-Length: 1250051</span><br><span class="line"></span><br><span class="line">----------------------------833910809558491007284810</span><br><span class="line">Content-Disposition: form-data; name=&quot;Hello&quot;; filename=&quot;Hello.swift&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">print(&quot;hello world&quot;)</span><br><span class="line">----------------------------833910809558491007284810</span><br><span class="line">Content-Disposition: form-data; name=&quot;image&quot;; filename=&quot;Pid89915350.jpg&quot;</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line"># image raw data</span><br><span class="line">----------------------------833910809558491007284810</span><br><span class="line">Content-Disposition: form-data; name=&quot;key1&quot;</span><br><span class="line"></span><br><span class="line">value1</span><br><span class="line">----------------------------833910809558491007284810--</span><br></pre></td></tr></table></figure><p>从上面可以看出其几个特点：</p><ul><li><strong>Content-Type</strong> 对应的值是 <strong>multipart&#x2F;form-data</strong> 表示这是一个 multipart request。</li><li>Content-Type 后面指定了一个分割符 boundary。后续在 body 中也是通过这个分割符分割不同的键值对。</li><li>body 中除了用分割符分割键值对之外，每个键值对都会指定 <strong>Content-Disposition</strong> 属性，如果是文件，还会在后面带上 filename。</li><li>如果是文件，还会根据文件类型指定 <strong>Content-Type</strong> 。</li></ul><p>了解完了 multiple request 的基本概念，下面来看看 AFNetworking 框架怎么处理这种请求。</p><p>下面是一些内部创建的类，AFNetworking 通过这些类来处理 multiple request 请求，这些类会在后面创建 request 的流程中进行更详细的介绍：</p><p><img src="https://res.craft.do/user/full/ea081854-0d6c-dace-b07b-5007ad758cc9/doc/BAA570CA-8DD7-4D68-9E22-C44B50358FF0/B94B9153-DB9A-4272-AC7E-97E551F23EB8_2/raPlHT80coNtIOSDen7w3Z74hyjDcOz9v2P2mLC4MY0z/AFMultipartFormData.png" alt="AFMultipartFormData.png"></p><p>AFNetworking 通过如下方法创建一个 multipart request：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)multipartFormRequestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                              URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                             parameters:(<span class="built_in">NSDictionary</span> *)parameters</span><br><span class="line">                              constructingBodyWithBlock:(<span class="type">void</span> (^)(<span class="type">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                                  error:(<span class="built_in">NSError</span> *__autoreleasing *)error;</span><br></pre></td></tr></table></figure><p>方法内部首先通过上面的 <code>requestWithMethod:URLString:parameters:error:</code> 方法创建一个带 method 的 request，但由于 multipart request 中的 parameters 的 key 可能是文件，因此调用该方法时 parameters 参数传入的是 <code>nil</code> 。</p><p>随后使用该创建的 request 初始化一个 <code>AFStreamingMultipartFormData</code> ，该类在初始化时会随机生成 multipart request 需要的分割符（boundary）。同时内部初始化一个 <code>AFMultipartBodyStream</code> 作为其属性 ，该类继承了 <code>NSInputStream</code> 并实现了 <code>NSStreamDelegate</code> 中的方法。再对数据进行处理后将在最后被设置到 request 的 httpBodyStream 上。</p><p>创建结束后，内部会遍历 parameters，对那些不是 <code>NSData</code> 的 value 进行转换（可能是普通字符类型），统一成 <code>NSData</code> 类型，随后调用 <code>AFStreamMultipartFormData</code> 的 <code>appendPartWithFormData:name:</code> 方法将其挨个加入到 form data 中。这个添加过程又分为以下几步：</p><ol><li>首先创建了一个 dictionary，然后设置了 <strong>Content-Disposition</strong> 值。</li><li>随后创建了一个 <code>AFHTTPBodyPart</code> 实例，每一个 <code>AFHTTPBodyPart</code> 的实例，其实就是代表了上面我们看到了 multipart request HTTP 头里面两个分割线之间的一块内容（一个键值对）。创建后将上面设置过的 dictionary 作为了 bodyPart 的 headers，传入的 data 作为其 body，同时设置了分割符和 content length。</li><li>最后将生成的这个 body part 加到上面生成的 body stream 里面。这个加入逻辑实际上就是将这个新生成 body part 放到了内部的一个 array 中。</li></ol><p>随后会调用参数中的 block，并将创建的 formData 实例传入。在 block 中，使用者可以调用 <code>AFMultipartFormData</code> 协议中的一些其他方法，将数据添加到 multipart request 的 body 中。比如:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)appendPartWithFileURL:(<span class="built_in">NSURL</span> *)fileURL</span><br><span class="line">                         name:(<span class="built_in">NSString</span> *)name</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br></pre></td></tr></table></figure><p>会通过在内部设置 <strong>Content-Disposition</strong> 和 <strong>Content-Type</strong> ，同样也生成一个 <code>AFHTTPBodyPart</code> 实例，并设置其 headers、body（设置为这里的 fileURL）等属性，最后添加到 body stream 里面。</p><p>multipart request 方法最后会调用 form data 的 <code>requestByFinalizingMultipartFormData</code> 方法生成一个 request 返回。该方法内部生成了一个 request，设置了其 <strong>Content-Type</strong> 为 <strong>multipart&#x2F;form-data; boundary&#x3D;…</strong>，同时 <strong>Content-Length</strong> 为 body stream 的大小<strong>。</strong>并设置了其 http body stream 为上面的 <code>AFMultipartBodyStream</code> 实例。另外还指定只有第一个和最后一个 body part 分别需要初始分割符和结束分割符。</p><p>由于 <code>AFMultipartBodyStream</code> 继承了 <code>NSInputStream</code> ，实际要去看发送时如何处理内部的 headers 和 body 还是需要去看它如何重写了 <code>read:maxLength:</code> 方法。该方法内部实现就是遍历内部的所有 <code>AFHTTPBodyPart</code> 实例然后调用每一个实例的 <code>read:maxLength:</code> 方法。</p><p>该方法内部通过 <code>AFHTTPBodyPart</code> 中定义的如下枚举类，分阶段将数据分布写进 buffer 中，每次写完一个阶段就会前往下一个阶段。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    AFEncapsulationBoundaryPhase = <span class="number">1</span>, <span class="comment">// 写初始分割符或者中间分割符的阶段</span></span><br><span class="line">    AFHeaderPhase                = <span class="number">2</span>, <span class="comment">// 写 headers 的阶段，包括 content-dispostion 等</span></span><br><span class="line">    AFBodyPhase                  = <span class="number">3</span>, <span class="comment">// 写 body 的阶段</span></span><br><span class="line">    AFFinalBoundaryPhase         = <span class="number">4</span>, <span class="comment">// 写结尾分割符的阶段，只有最后一个 body part 有这个阶段</span></span><br><span class="line">&#125; AFHTTPBodyPartReadPhase;</span><br></pre></td></tr></table></figure><p>第 1、2、4 阶段都是将字符串转换为 <code>NSData</code> 然后写入，2 阶段写入前，会讲所有的 headers 以 <code>key: value</code> 的形式拼接起来，并以换行符串联成一个整的字符串。</p><p>第 3 阶段则会根据当前 body 的类型（<code>NSData</code> <code>NSURL</code> 或者 <code>NSInputStream</code>）初始化一个 <code>NSInputStream</code> ，并从中读取。</p><p>以上就是整个 multipart request 生成和处理的过程。</p><p><code>AFHTTPRequestSerializer</code> 的两个子类 <code>AFJSONRequestSerializer</code> 和 <code>AFPropertyListRequestSerializer</code> 其父类的处理类似。不过分别将 <strong>Content-Type</strong> 设置为了 <strong>application&#x2F;json</strong> 和 <strong>application&#x2F;x-plist</strong> 。最后还是将对应格式的数据转换为了 <code>NSData</code> 设置到了 HTTP body 上。</p><h2 id="AFHTTPResponseSerializer"><a href="#AFHTTPResponseSerializer" class="headerlink" title="AFHTTPResponseSerializer"></a>AFHTTPResponseSerializer</h2><p>对 response 进行格式化的类相对而言比较简单，实际使用时主要使用 <code>AFHTTPResponseSerializer</code> 的特定格式的子类，如 <code>AFJSONResponseSerializer</code> , <code>AFXMLParserResponseSerializer</code> 等。</p><p>核心作用是通过以下方法将 response 解析成对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error;</span><br></pre></td></tr></table></figure><p>其主要过程首先是检查状态码看请求是否成功，然后检查一些 response 的参数是否齐全，如 <strong>Content-Type</strong> ，随后还会检查其中的 <strong>Content-Type</strong> 是否是对应的格式（如使用 <code>AFJSONResponseSerializer</code> 要求值为 <code>@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;</code> 中的一种）。最后使用对应的解析器将数据解析为对象。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;研究了 AFNetworking 网络框架的主要结构和方法，对其内部如何建立一个请求，做了哪些额外工作，特别是如何发送一个 multipart request 请求进行了较为深入的分析。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>🍱 iOS 自动布局和 Masonry 框架</title>
    <link href="http://example.com/2022/03/28/%F0%9F%8D%B1%20iOS%20%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%92%8C%20Masonry%20%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2022/03/28/%F0%9F%8D%B1%20iOS%20%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%92%8C%20Masonry%20%E6%A1%86%E6%9E%B6/</id>
    <published>2022-03-28T03:28:00.000Z</published>
    <updated>2022-04-27T13:47:10.525Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍了一些关于 iOS 自动布局的概念，并对 Masonry 框架进行了分析。主要介绍了 Masonry 框架主要结构，使用时内部调用过程和一些需要注意的细节。</p><span id="more"></span><h2 id="iOS-布局方法"><a href="#iOS-布局方法" class="headerlink" title="iOS 布局方法"></a>iOS 布局方法</h2><p>iOS 发展早期由于设备屏幕大小固定，因此不需要考虑屏幕大小差异产生的适配问题，采用的是直接指定 View 的位置和大小：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"><span class="comment">// 指定 view 的左端，上端距离父 view 的距离为10，宽高均为 50</span></span><br><span class="line">view.frame = <span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>设定一个 view 的布局，需要每次都对以上属性进行计算。当需要改变时，需要对上面的4个属性进行重新计算。</p><p>后来苹果对每一个 view 添加了 <code>autoresizingMask</code> 属性，能够让一个 view 在父 view 进行变动时根据这个属性来进行调整。如 <code>UIViewAutoresizingFlexibleLeftMargin</code> 表示该 view 在父 view 变动时，左边边距可以进行变化。可以使用位与运算连接多个这样的属性。</p><p>autoresizingMask 也存在其局限性，由于其只能设置和父 view 之间的关系，缺乏灵活性，只能用于一小部分的约束设置。</p><p>之后从 iOS6 开始，苹果引入了自动布局，通过一种约束来设置 view 之间的关系，帮助开发者更方便快捷的适配多种大小的屏幕。</p><p>一个约束（constraint）通常可以表示为一个以下的等式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Item A&#x27;s Attribute = Multiplier * Item B&#x27;s Attribute + Constant</span><br></pre></td></tr></table></figure><p>通过所有 view 上的约束，转换为一个线性规划问题，并最终进行求解，详情可参考论文 <a href="https://constraints.cs.washington.edu/solvers/uist97.pdf">《Solving Linear Arithmetic Constraints for User Interface Applications》</a>。</p><blockquote><p>由于自动布局涉及到计算，因此通常性能会较 frame 的布局方式差。</p></blockquote><h2 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h2><p>由于官方提供的自动布局 api 较为繁琐，通常设置一个约束就要写下如下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// view1 上端距离 view2 上端 10</span></span><br><span class="line">[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                             attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                             relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                toItem:view2</span><br><span class="line">                             attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                            multiplier:<span class="number">1.0</span></span><br><span class="line">                              constant:padding.top]</span><br></pre></td></tr></table></figure><p>因此在日常开发中，我们通常会使用 <a href="https://github.com/SnapKit/Masonry">Masonry</a> 框架进行开发，Masonry 框架封装了官方 api 并提供了一种简单的链式调用语法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也是 view1 离 view2 顶部有 10 的距离</span></span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view2.mas_top).mas_offset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>而在添加多个约束时，Masonry 会更加方便。</p><p>通过学习 Masonry 的源码，我们能够进一步了解自动布局，并减少在日常开发中引入的布局问题。</p><p>Masonry 中的 <code>MASViewAttribute</code> 代表了公式中的一个 item and Attribute。<code>MASConstraints</code> 代表了上文中的一个约束公式，最终通过官方的 api 激活成 <code>NSLayoutConstraints</code> 加到view上面。</p><p>Masonry 中的一些类大致关系如图所示：</p><p><img src="https://res.craft.do/user/full/ea081854-0d6c-dace-b07b-5007ad758cc9/doc/0F73AF4D-EB6C-437C-9640-A7EA15797C87/0FE954FF-5CEF-4346-B71A-CF09E47B9D10_2/O5fsv2WRqFy69E0Gv7UOsopv4bod0jOb7chSbOYxqJ8z/Masonry.png" alt="Masonry.png"></p><p>下文中我们将首先对一些类进行分析，最后进行3个日常中最常见实例的分析，进一步了解整个框架的工作过程。</p><h3 id="View-MASAdditions"><a href="#View-MASAdditions" class="headerlink" title="View+MASAdditions"></a>View+MASAdditions</h3><p>定义了一些 <code>MASViewAttribute</code> 属性，如 <code>mas_top</code> 等。这些属性的 getter 都是传入 self 作为 view，并传入对应的 <code>NSLayoutAttribute</code> 对 <code>MASViewAttribute</code> 进行初始化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (MASViewAttribute *)mas_top &#123;</span><br><span class="line">    <span class="keyword">return</span> [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span> layoutAttribute:<span class="built_in">NSLayoutAttributeTop</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>MASViewAttribute</code> 主要包括一个 view 和一个 <code>NSLayoutAttribute</code>。</p></blockquote><p>定义了 <code>mas_makeConstraints</code>, <code>mas_updateConstraints</code> 和 <code>mas_remakeConstraints</code> 三个方法。这三个方法也是使用 Masonry 的核心方法，分别的使用场景为：</p><ul><li><code>mas_makeConstraints</code>：最初创建 constraints 时使用。</li><li><code>mas_updateConstraints</code>：对于某个 constraint 的常数进行更改时使用，注意该方法只能更新 constraint 的常数。如果希望重新设置针对的 view，需要使用 <code>mas_remakeConstraints</code>。原因将在后面实例分析的最后步骤中进行进一步讲解。</li><li><code>mas_remakeConstraints</code> 将会移除之前的所有 constraint，并进行重新设置，注意一定要保证重新设置后的 constraint 依然能够完整的确定该 view 的位置和大小。</li></ul><p>上面三个方法流程一致，都是创建了一个 <code>MASConstraintMaker</code>，并将其作为参数传入方法参数的 block 中。最后调用 <code>[MASConstraintMaker install]</code>。其中 update 设置了 installer 的 <code>updateExisting</code> 为 YES，remake 设置了 installer 的 <code>removeExisting</code> 为 YES。</p><p><code>translatesAutoresizingMaskIntoConstraints</code> 属性为 YES，将会把对 frame 的设置自动转换为自动布局约束，但这种自动转换可能会带来约束上的冲突，因此设置为 NO，会将对 frame 的设置忽略。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="type">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这三个方法头文件中对 block 加了 <code>void(^NS_NOESCAPE)</code> 限制，表示该 block 会在方法结束前被调用完成，编译器能利用这个信息更好的管理内存，同时，我们也不需要传入 weak self。</p></blockquote><blockquote><p>objective-c 默认是 escaping，Swift 默认是 no escape，Swift 中使用 <code>@escaping</code> 关键字。</p></blockquote><h3 id="View-MASShorthandAdditions"><a href="#View-MASShorthandAdditions" class="headerlink" title="View+MASShorthandAdditions"></a>View+MASShorthandAdditions</h3><p>如果定义了 <code>MAS_SHORTHAND</code> 宏，就可以使用 <code>top</code> 代替 <code>mas_top</code>，使用 <code>makeConstraints</code> 代替 <code>mas_makeConstraints</code>，这些缩写的定义，实际上还是调用了有 <code>mas_</code> 开头的方法和属性。</p><p>搜了下主站里面没有地方有 <code>#define MAS_SHORTHAND</code>。因此在主站开发中按照标准写法还是应该调用带有 <code>mas_</code> 的属性。</p><blockquote><p>📌 对主站里面有写缩写的地方 jump to definition 跳转到了 UIView+KSGeometry。编译器没有对于一些地方类似于使用 <code>.bottom</code> 代替 <code>.mas_bottom</code> 的写法没有报错的原因只是因为工程内部实现了一个能返回 view 底部 view 位置浮点数的方法，但这种写法其实在 <code>mas_equalTo</code> 中传入的是一种绝对值，实际提供的约束规则是相对于 superview 多少个像素（传入常数时，将会设置成相对于其 superview 对应方位的距离），可能后续维护的时候会遇到一些问题。</p></blockquote><p>我进一步在主站内对上面进行尝试了一下，如果是同时进行自动布局的一个另一个 view2 对其的属性使用所写的方式，由于其没渲染完，一般会返回0，此时在某些情况下是不会有问题的，比如 view2 是 view1 的父 view，如下面的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">[view1 addSubview:view2];</span><br><span class="line"></span><br><span class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view1.top).mas_equalTo(<span class="number">10</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>此时由于 view1.top 取到的是 0，相当于设定 view2 的顶部距离其 superview 是 0+10，和预期是相同的。因此不会出错。</p><p>另一种可能性可能是看起来不会出错，比如设定相对于 view controller 里面 view 的 bottom：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in a view controller</span></span><br><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:view];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    ...</span><br><span class="line">    make.bottom.mas_equalTo(<span class="keyword">self</span>.view.bottom);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>假设根据分类的定义，这个时候 <code>self.view.bottom</code> 返回了 1000 其实相当于设置 <code>make.bottom.mas_equalTo(self.view.mas_bottom).mas_offset(1000)</code>，但由于多出的部分都在屏幕外面，因此看起来和正确的设置方式没有区别。</p><h3 id="NSArray-MASAdditions"><a href="#NSArray-MASAdditions" class="headerlink" title="NSArray+MASAdditions"></a>NSArray+MASAdditions</h3><p>同样提供了 <code>mas_makeConstraints</code>, <code>mas_updateConstraints</code> 和 <code>mas_remakeConstraints</code> 三个方法。通过数组调用这三个方法时，要保证数组中的所有元素都是 <code>UIView</code> 类型，这三个方法的调用内部会遍历整个数组内的所有 view，并针对每个 view 调用对应的方法来设置 view 的约束。</p><p>多提供了两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedSpacing:(<span class="built_in">CGFloat</span>)fixedSpacing leadSpacing:(<span class="built_in">CGFloat</span>)leadSpacing tailSpacing:(<span class="built_in">CGFloat</span>)tailSpacing;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedItemLength:(<span class="built_in">CGFloat</span>)fixedItemLength leadSpacing:(<span class="built_in">CGFloat</span>)leadSpacing tailSpacing:(<span class="built_in">CGFloat</span>)tailSpacing;</span><br></pre></td></tr></table></figure><p>也是通过计算并对每一个 view 调用 <code>mas_makeConstraints</code>。但我目前感觉不如使用 <a href="https://nshipster.com/uistackview/"><code>UIStackView</code></a>，并将 distribution 设置为 <code>UIStackViewDistributionEqualSpacing</code> 和 <code>UIStackViewDistributionFillEqually</code>。</p><blockquote><p>不过 stack view <a href="https://github.com/layoutBox/LayoutFrameworkBenchmark">性能相对于 autolayout 会稍微差一点</a>，但如果只有几个 view 感觉问题不是很大。</p></blockquote><blockquote><p>To be on the safe side, avoid using deeply nested stack views, especially in reusable views such as table and collection view cells. (See <a href="https://nshipster.com/uistackview/">nshipster</a>)</p></blockquote><h3 id="NSArray-MASShorthandAdditions"><a href="#NSArray-MASShorthandAdditions" class="headerlink" title="NSArray+MASShorthandAdditions"></a>NSArray+MASShorthandAdditions</h3><p>与 UIView+MASShorthandAdditions 类似，提供了在定义 <code>MAS_SHORTHAND</code> 宏前提下，可以在 <code>NSArray</code> 上调用 <code>makeConstraints</code> 来代替调用 <code>mas_makeConstraints</code>，调用 <code>updateConstraints</code> 来代替 <code>mas_updateConstraints</code> 和调用 <code>remakeConstraints</code> 来代替 <code>mas_remakeConstraints</code> 的能力。</p><h3 id="MASViewAttribute"><a href="#MASViewAttribute" class="headerlink" title="MASViewAttribute"></a>MASViewAttribute</h3><p>主要包括以下的一些属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The view which the reciever relates to. Can be nil if item is not a view.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) MAS_VIEW *view;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The item which the reciever relates to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="type">id</span> item;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The attribute which the reciever relates to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSLayoutAttribute</span> layoutAttribute;</span><br></pre></td></tr></table></figure><p><code>MAS_View</code> 实际上是一个 <code>UIView</code> 的别名，因此该类实际上封装了一个 view 和一个 attribute，对应了文章开头中自动布局公式中的一组 <code>Item&#39;s Attribute</code>。</p><h3 id="MASConstraint"><a href="#MASConstraint" class="headerlink" title="MASConstraint"></a>MASConstraint</h3><p>代表了一个未激活的 constraint，该类中提供了诸如 top，left 等方法，但其功能都需要在子类中实现。详细调用逻辑可以参考后面的实例分析部分。</p><h3 id="MASConstraintMaker"><a href="#MASConstraintMaker" class="headerlink" title="MASConstraintMaker"></a>MASConstraintMaker</h3><p>提供了一个 <code>install</code> 方法，该方法实际上调用了自己每个 <code>MASConstraint</code> 的 <code>install</code> 方法，如果 <code>removeExisting</code> 是 YES，先 <code>uninstall</code> 存在的 constraints，如果 <code>updateExisting</code> 是 YES，把每个 constraints 的 updateExisting 设置为 YES.</p><p>Maker 的属性如 left 调用的时候都相当于把对应的 attribute 添加到 maker 的 constraints 数组里面，并且返回一个 MASConstraints。</p><p>单个属性返回的是一个 <code>MASViewConstraint</code>，而组合属性如 edges 返回的是一个 <code>MASCompositeConstraint</code>。这两个都是 <code>MASConstraints</code> 的子类。实现了 <code>addConstraintWithLayoutAttribute</code> 方法和一些其他重要方法比如 <code>install</code>。</p><p>具体使用逻辑可以参考后面的实例分析部分。</p><h3 id="MASViewConstraint"><a href="#MASViewConstraint" class="headerlink" title="MASViewConstraint"></a>MASViewConstraint</h3><p>主要包括以下一些重要属性。</p><p>头文件里包括两个 <code>MASViewAttribute</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  First item/view and first attribute of the NSLayoutConstraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *firstViewAttribute;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Second item/view and second attribute of the NSLayoutConstraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *secondViewAttribute;</span><br></pre></td></tr></table></figure><p>.h 文件中的一些属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MAS_VIEW *installedView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MASLayoutConstraint *layoutConstraint;</span><br><span class="line"><span class="comment">/// 两个 attribute 之间的关系，可能是等于，小于等于，大于等于</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSLayoutRelation</span> layoutRelation;</span><br><span class="line"><span class="comment">/// 限制的优先度，默认是 MASLayoutPriorityRequired</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) MASLayoutPriority layoutPriority;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> layoutMultiplier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> layoutConstant;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> hasLayoutRelation;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> mas_key;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> useAnimator;</span><br></pre></td></tr></table></figure><p>初始化方法在 <code>MASConstraintMaker</code> 被调用，用来添加约束，约束默认的 <a href="https://developer.apple.com/documentation/uikit/uilayoutpriority?language=objc">priority</a> 都是 <code>MASLayoutPriorityRequired</code>。multipler 都是 1。</p><ul><li><code>left</code> 实际上调用的是 delegate 的 <code>- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code> 方法，delegate 是 <code>MASConstraintMaker</code>。里面把这个新的约束加到了 maker 的 constraints 数组里面的。</li><li><code>equalTo</code>，<code>greaterThanOrEqualTo</code> 和 <code>lessThanOrEqualTo</code> 都调用了 <code>equalToWithRelation</code>，但传入的第二个参数（layoutRelation）不一样，这个也是在子类里面被实现的。<code>equalTo</code> 后面嗯能用括号是因为返回的是一个 block。如果传入的是一个 view，设置自己的 layoutRelation 是 relation，secondAttribute 是那个传入的 view（如果传入的是一个 NSValue 或者 CGPoint，CGSize，将会先看 attribute 符不符合，然后更改 layoutConstant）。如果传入的是一个数组，会转换成一个 <code>MASCompositeConstraint</code>。</li><li><code>insets</code> 要传入一个 UIEdgeInset 参数，将会吧 firstAttribute 里面的对应参数变成 edgeInset 里面的值。<code>inset</code> 实际调用了一个 <code>insets</code> 并将 4 面都设置为传入的值。<code>offset</code> 更改了 <code>layoutConstant</code> 值。<code>mas_offset</code> 和之前的 <code>equalTo</code> 一样增加了 auto boxing，对于传入 view 和 number 有不同的处理。</li><li><code>with</code> 和 <code>and</code> 都直接返回 <code>self</code> 只是为了帮助链式调用的读法更加通顺。如 <code>make.width.and.height.equalTo(self.bottomView).with.priorityLow();</code>，实际使用时可以不写。</li><li><code>priorityLow</code> 实际上调用了 <code>.priority</code> 并将对应的优先级作为参数传入。</li></ul><p>具体如何被调用可以参考后文中的案例分析1和2。</p><h3 id="MASCompositeConstraint"><a href="#MASCompositeConstraint" class="headerlink" title="MASCompositeConstraint"></a>MASCompositeConstraint</h3><p>包含多个 <code>MASViewConstraint</code> 的一个 constraint，会在链式调用同时设置多个 attribute 时被创建，如 <code>make.left.and.right.equalTo(view).offset(@10)</code>。对于父类中的方法实现基本就是调用了包含的每一个 <code>MASViewConstraint</code> 的同名方法。</p><p>具体如何被生成可以参考后文中的案例分析3。</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view2).mas_offset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>mas_makeConstraints</code> 的调用，创建了一个 <code>MASConstraintMaker</code> 实例，并且将其 <code>view</code> 属性设置为 <code>view1</code>。然后将该新建的 maker 作为参数传入到 block 中，调用整个 block。</p><p>调用 <code>.top</code> 分别创建了一个 attribute 和一个 constraints</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br></pre></td></tr></table></figure><p>并将这个 newConstraint 的 delegate 设置成 maker，再将其加入到 maker 的 <code>constraints</code> 数组中。并返回一个 <code>MASViewConstraints</code>，返回的就是 <code>newConstraint</code>，也就是说后面的链式操作实际上都是在对一个已加入到 constraints 数组的进行修改。</p><p><code>mas_equalTo</code> 调用了 <code>MASViewConstraints</code> 的 <code>equalToWithRelation</code> 方法，其第一个参数是一个 <code>id</code> 类型，这里将 <code>view2</code> 作为这个参数传入。方法中将会将 constraints 的 <code>layoutRelation</code> 设置为对应的 relation，这里是 <code>NSLayoutRelationEqual</code>。并且传入 <code>view2</code> 来设置 constraints 的 <code>secondAttribute</code> 属性。在 setter 中，新生成一个 <code>MASViewAttribute</code>，该 <code>MASViewAttribute</code> 的 <code>view</code> 就是 view2，而 <code>attribute</code> 和 view1 的 attribute 相同。最后也同样会返回一个 <code>MASConstraint</code>。</p><blockquote><p>如果 <code>equalTo</code> 里面是一个数字就会直接去设置 constraints 的 layoutConstant。</p></blockquote><p><code>mas_offset</code> 会把 <code>MASConstraint</code> 的 offset 设置为 10，offset 的 setter 方法会将 <code>layoutConstant</code> 设置为该常数，之后仍会返回一个 <code>MASConstraint</code>，但到了此时，一个 <code>MASConstraint</code> 的所有属性已经设置完成.</p><h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view2.mas_bottom).mas_offset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>和上面基本一样，但此时设置 <code>secondAttribute</code> 的时候传入的是一个 <code>MASAttribute</code>，这个 attribute 的 <code>view</code> 和 <code>item</code> 属性都初始化为 <code>view2</code>，同时 <code>layoutAttribute</code> 属性被设置为 <code>NSLayoutAttributeBottom</code>。<code>secondAttribute</code> 被直接设置为这个 attribute。</p><h4 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.leading.and.trailing.mas_equalTo(view2.mas_bottom).inset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>make.leading.and</code> 和上面一样，往 maker 的 constraints 数组里面添加了一个 constraints。<code>MASConstraints</code> 的 <code>.trailing</code> 会调用其 <code>addConstraintWithLayoutAttribute</code> 方法，这个方法在子类中被实现，<code>MASViewConstraints</code>  的该方法调用了其 delegate 的 <code>- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code> 方法，也就是 <code>MASConstraintMaker</code> 的该方法。但和最开始 <code>make.leading</code> 调用所不同的是，之前的第一个参数 constraint 传的是 <code>nil</code>，现在传的是 <code>self</code> 也就是 <code>make.leading</code> 生成的 <code>MASConstraint</code>。此时会将两个 constraints 合成一个 <code>MASCompositeConstraint</code>，该类是 <code>MASConstraints</code>  的另一个子类。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class="line">MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">compositeConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line"><span class="keyword">return</span> compositeConstraint;</span><br></pre></td></tr></table></figure><p><code>MASCompositeConstraint</code> 的初始化方法中，将会把所有的 children 中的 constraint 的 delegate 设置为 compositeConstraint 自身。</p><p><code>shouldBeReplacedWithConstraint</code> 中将会把 maker 中的 constraints 属性中的 <code>constraint</code> 替换成 <code>compositionConstraint</code>。</p><p>最后一个 <code>MASCompositeConstraints</code> 将会被返回。</p><p>如果我们继续添加属性，比如在 <code>trailing</code> 后添加 <code>.bottom</code>，此时调用的是 <code>MASCompositeConstraint</code> 的 <code>addConstraintWithLayoutAttribute</code> 的方法。里面调用了 <code>MASConstraintsMaker</code> 的 <code>[strongDelegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute]</code> 方法（<code>strongDelegate</code> 就是 compositeConstraints 的 delegate，也就是 maker。由于第一个参数不是一个 <code>nil</code> 也不是 <code>viewConstraints</code>，会直接返回一个 <code>MASConstraint</code> 并被 <code>MASCompositeConstraints</code> 加入到 children 数组中。</p><p><code>MASCompositeConstraints</code> 的 <code>inset</code> 或者 <code>offset</code> 方法会遍历所有的 children 中的并调用对应的方法（<code>inset</code> 或者 <code>offset</code>）最终其实和之前的 mas_offset 一样都是对 constraint 的 layoutConstant 属性进行了设置，inset 只是帮你在 bottom，trailing 和 bottom 的情况下加上了负号。</p><h4 id="最后步骤"><a href="#最后步骤" class="headerlink" title="最后步骤"></a>最后步骤</h4><p>上面三个案例的 block 执行结束后都会调用 maker 的 <code>install</code> 方法。其定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)install &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</span><br><span class="line">            [constraint uninstall];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *constraints = <span class="keyword">self</span>.constraints.copy;</span><br><span class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> constraints) &#123;</span><br><span class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.constraints removeAllObjects];</span><br><span class="line">    <span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeExisting</code> 和 <code>updateExisting</code> 会在调用 <code>mas_remakeConstraints</code> 和 <code>mas_updateConstraints</code> 的时候被设置。可以看到 install 就是遍历自己的 constraints 数组（都是在 block 里面添加的），并对里面的每一个 constraint 调用 install 方法（该方法都在子类里面实现）。</p><p><code>MASViewConstraints</code> 对于 install 的实现步骤如下：</p><ol><li>分别拿出 firstAttribute 和 secondAttribute 中的 item（item1，item2） 和 attribute（attribute1，attribute2），如果 second attribute 为 nil（比如 <code>make.left.equalTo(@10)</code>)，会将 item2 设置为 item1 的 superview，attribute2 设置为 attribute1。</li><li>调用系统方法获得一个 layout constraints</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MASLayoutConstraint *layoutConstraint <span class="comment">// MASLayoutConstraint 是一个 NSLayoutConstraint 的子类</span></span><br><span class="line">        = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line">                                        attribute:firstLayoutAttribute</span><br><span class="line">                                        relatedBy:<span class="keyword">self</span>.layoutRelation</span><br><span class="line">                                           toItem:secondLayoutItem</span><br><span class="line">                                        attribute:secondLayoutAttribute</span><br><span class="line">                                       multiplier:<span class="keyword">self</span>.layoutMultiplier</span><br><span class="line">                                         constant:<span class="keyword">self</span>.layoutConstant];</span><br><span class="line">layoutConstraint.priority = <span class="keyword">self</span>.layoutPriority;</span><br></pre></td></tr></table></figure><ol start="3"><li>查找这个 constraints 的 installedView（被添加到的 view 上，如果 item1，item2都是 view，那就是他们共同的 superview，从这一点也可以看出只有拥有同一个 superview 的两个 view 之间才能添加属性约束（包括一个是另一个的 superview）；如果 attribute1 是某种 size 属性，那就是 item1；如果 item2 不存在那就是 item1 的父 view）是否有相同的 layoutConstraint</li></ol><p>如果存在同样的 layoutConstraint，就更新对应的 layoutConstraint，因此使用 <code>mas_updateConstraints</code> 要注意只能帮你更新只修改 constant 的 constraint。</p><blockquote><p>要求该 constraint 的 firstItem, secondItem, firstAttribute, secondAttribute, relation, multiplier, priority 一样。</p></blockquote><ol start="4"><li>如果没有相同的 constraints 就对该 constraints 进行激活。</li></ol><p><code>MASCompositeConstraint</code> 的 <code>install</code> 实际上就是遍历 children 里面的所有 constraints 并调用其 install 方法。</p><h4 id="案例总结"><a href="#案例总结" class="headerlink" title="案例总结"></a>案例总结</h4><ul><li><code>mas_makeConstraints</code> block 中的一条语句会生成一个 <code>MASConstraints</code> 的子类，如果是单个约束会生成一个 <code>MASViewConstraints</code>，如果是多个约束会生成一个 <code>MASCompositeConstraint</code>（实际内部还是包括了很多个 <code>MASViewConstraints</code>）。</li><li><code>view.mas_top</code> 这样的语句返回的是一个 <code>MASAttribute</code>。</li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="使用-inset-还是-mas-offset"><a href="#使用-inset-还是-mas-offset" class="headerlink" title="使用 inset 还是 mas_offset"></a>使用 <code>inset</code> 还是 <code>mas_offset</code></h4><p>实际实现都是一样的，都设置了 constraint 的 layoutConstant 属性，但 <code>inset</code> 会在 trailing，right 和 bottom 的时候添加负号。</p><h4 id="mas-equalTo-和-equalTo"><a href="#mas-equalTo-和-equalTo" class="headerlink" title="mas_equalTo 和 equalTo"></a><code>mas_equalTo</code> 和 <code>equalTo</code></h4><p><code>mas_equalTo</code> 是一个定义的宏，将会对传入值进行 autoboxing 成 <code>NSNumber</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mas_equalTo(...)                 equalTo(MASBoxValue((__VA_ARGS__)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value)) <span class="comment">// In MASUtilities.h</span></span></span><br></pre></td></tr></table></figure><p><a href="https://nshipster.cn/type-encodings/"><code>@encode</code></a> 得到值的类型，通过可变参数列表，使用 <code>strcmp</code> 对比参数和类型，相同时就将参数转换成该类型。</p><blockquote><p><code>MASConstraint (AutoboxingSupport)</code> 中也定义了一个 <code>mas_equal</code> ）将其实现为和 <code>equalTo</code> 一致。实际调用的时候都是用的宏，添加一个同名的方法能够使宏能够有自动补全的能力。</p></blockquote><h4 id="使用-trailing-还是-right"><a href="#使用-trailing-还是-right" class="headerlink" title="使用 trailing 还是 right"></a>使用 <code>trailing</code> 还是 <code>right</code></h4><p>大多数情况下含义一样，但要注意对于一些从右到左的语言，比如阿拉伯语，<code>trailing</code> 实际代表的是 <code>left</code>。基本上使用 <code>trailing</code> 总是更保险的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍了一些关于 iOS 自动布局的概念，并对 Masonry 框架进行了分析。主要介绍了 Masonry 框架主要结构，使用时内部调用过程和一些需要注意的细节。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
