<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jjakj1&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-27T13:47:10.525Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Shanyu Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>🍱 iOS 自动布局和 Masonry 框架</title>
    <link href="http://example.com/2022/03/28/%F0%9F%8D%B1%20%20iOS%20%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%92%8C%20Masonry%20%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2022/03/28/%F0%9F%8D%B1%20%20iOS%20%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%92%8C%20Masonry%20%E6%A1%86%E6%9E%B6/</id>
    <published>2022-03-28T03:28:00.000Z</published>
    <updated>2022-04-27T13:47:10.525Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍了一些关于 iOS 自动布局的概念，并对 Masonry 框架进行了分析。主要介绍了 Masonry 框架主要结构，使用时内部调用过程和一些需要注意的细节。</p><span id="more"></span><h2 id="iOS-布局方法"><a href="#iOS-布局方法" class="headerlink" title="iOS 布局方法"></a>iOS 布局方法</h2><p>iOS 发展早期由于设备屏幕大小固定，因此不需要考虑屏幕大小差异产生的适配问题，采用的是直接指定 View 的位置和大小：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"><span class="comment">// 指定 view 的左端，上端距离父 view 的距离为10，宽高均为 50</span></span><br><span class="line">view.frame = <span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>设定一个 view 的布局，需要每次都对以上属性进行计算。当需要改变时，需要对上面的4个属性进行重新计算。</p><p>后来苹果对每一个 view 添加了 <code>autoresizingMask</code> 属性，能够让一个 view 在父 view 进行变动时根据这个属性来进行调整。如 <code>UIViewAutoresizingFlexibleLeftMargin</code> 表示该 view 在父 view 变动时，左边边距可以进行变化。可以使用位与运算连接多个这样的属性。</p><p>autoresizingMask 也存在其局限性，由于其只能设置和父 view 之间的关系，缺乏灵活性，只能用于一小部分的约束设置。</p><p>之后从 iOS6 开始，苹果引入了自动布局，通过一种约束来设置 view 之间的关系，帮助开发者更方便快捷的适配多种大小的屏幕。</p><p>一个约束（constraint）通常可以表示为一个以下的等式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Item A&#x27;s Attribute = Multiplier * Item B&#x27;s Attribute + Constant</span><br></pre></td></tr></table></figure><p>通过所有 view 上的约束，转换为一个线性规划问题，并最终进行求解，详情可参考论文 <a href="https://constraints.cs.washington.edu/solvers/uist97.pdf">《Solving Linear Arithmetic Constraints for User Interface Applications》</a>。</p><blockquote><p>由于自动布局涉及到计算，因此通常性能会较 frame 的布局方式差。</p></blockquote><h2 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h2><p>由于官方提供的自动布局 api 较为繁琐，通常设置一个约束就要写下如下代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// view1 上端距离 view2 上端 10</span></span><br><span class="line">[<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                             attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                             relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                                toItem:view2</span><br><span class="line">                             attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                            multiplier:<span class="number">1.0</span></span><br><span class="line">                              constant:padding.top]</span><br></pre></td></tr></table></figure><p>因此在日常开发中，我们通常会使用 <a href="https://github.com/SnapKit/Masonry">Masonry</a> 框架进行开发，Masonry 框架封装了官方 api 并提供了一种简单的链式调用语法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也是 view1 离 view2 顶部有 10 的距离</span></span><br><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view2.mas_top).mas_offset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>而在添加多个约束时，Masonry 会更加方便。</p><p>通过学习 Masonry 的源码，我们能够进一步了解自动布局，并减少在日常开发中引入的布局问题。</p><p>Masonry 中的 <code>MASViewAttribute</code> 代表了公式中的一个 item and Attribute。<code>MASConstraints</code> 代表了上文中的一个约束公式，最终通过官方的 api 激活成 <code>NSLayoutConstraints</code> 加到view上面。</p><p>Masonry 中的一些类大致关系如图所示：</p><p><img src="https://res.craft.do/user/full/ea081854-0d6c-dace-b07b-5007ad758cc9/doc/0F73AF4D-EB6C-437C-9640-A7EA15797C87/0FE954FF-5CEF-4346-B71A-CF09E47B9D10_2/O5fsv2WRqFy69E0Gv7UOsopv4bod0jOb7chSbOYxqJ8z/Masonry.png" alt="Masonry.png"></p><p>下文中我们将首先对一些类进行分析，最后进行3个日常中最常见实例的分析，进一步了解整个框架的工作过程。</p><h3 id="View-MASAdditions"><a href="#View-MASAdditions" class="headerlink" title="View+MASAdditions"></a>View+MASAdditions</h3><p>定义了一些 <code>MASViewAttribute</code> 属性，如 <code>mas_top</code> 等。这些属性的 getter 都是传入 self 作为 view，并传入对应的 <code>NSLayoutAttribute</code> 对 <code>MASViewAttribute</code> 进行初始化。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (MASViewAttribute *)mas_top &#123;</span><br><span class="line">    <span class="keyword">return</span> [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span> layoutAttribute:<span class="built_in">NSLayoutAttributeTop</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>MASViewAttribute</code> 主要包括一个 view 和一个 <code>NSLayoutAttribute</code>。</p></blockquote><p>定义了 <code>mas_makeConstraints</code>, <code>mas_updateConstraints</code> 和 <code>mas_remakeConstraints</code> 三个方法。这三个方法也是使用 Masonry 的核心方法，分别的使用场景为：</p><ul><li><code>mas_makeConstraints</code>：最初创建 constraints 时使用。</li><li><code>mas_updateConstraints</code>：对于某个 constraint 的常数进行更改时使用，注意该方法只能更新 constraint 的常数。如果希望重新设置针对的 view，需要使用 <code>mas_remakeConstraints</code>。原因将在后面实例分析的最后步骤中进行进一步讲解。</li><li><code>mas_remakeConstraints</code> 将会移除之前的所有 constraint，并进行重新设置，注意一定要保证重新设置后的 constraint 依然能够完整的确定该 view 的位置和大小。</li></ul><p>上面三个方法流程一致，都是创建了一个 <code>MASConstraintMaker</code>，并将其作为参数传入方法参数的 block 中。最后调用 <code>[MASConstraintMaker install]</code>。其中 update 设置了 installer 的 <code>updateExisting</code> 为 YES，remake 设置了 installer 的 <code>removeExisting</code> 为 YES。</p><p><code>translatesAutoresizingMaskIntoConstraints</code> 属性为 YES，将会把对 frame 的设置自动转换为自动布局约束，但这种自动转换可能会带来约束上的冲突，因此设置为 NO，会将对 frame 的设置忽略。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="type">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这三个方法头文件中对 block 加了 <code>void(^NS_NOESCAPE)</code> 限制，表示该 block 会在方法结束前被调用完成，编译器能利用这个信息更好的管理内存，同时，我们也不需要传入 weak self。</p></blockquote><blockquote><p>objective-c 默认是 escaping，Swift 默认是 no escape，Swift 中使用 <code>@escaping</code> 关键字。</p></blockquote><h3 id="View-MASShorthandAdditions"><a href="#View-MASShorthandAdditions" class="headerlink" title="View+MASShorthandAdditions"></a>View+MASShorthandAdditions</h3><p>如果定义了 <code>MAS_SHORTHAND</code> 宏，就可以使用 <code>top</code> 代替 <code>mas_top</code>，使用 <code>makeConstraints</code> 代替 <code>mas_makeConstraints</code>，这些缩写的定义，实际上还是调用了有 <code>mas_</code> 开头的方法和属性。</p><p>搜了下主站里面没有地方有 <code>#define MAS_SHORTHAND</code>。因此在主站开发中按照标准写法还是应该调用带有 <code>mas_</code> 的属性。</p><blockquote><p>📌 对主站里面有写缩写的地方 jump to definition 跳转到了 UIView+KSGeometry。编译器没有对于一些地方类似于使用 <code>.bottom</code> 代替 <code>.mas_bottom</code> 的写法没有报错的原因只是因为工程内部实现了一个能返回 view 底部 view 位置浮点数的方法，但这种写法其实在 <code>mas_equalTo</code> 中传入的是一种绝对值，实际提供的约束规则是相对于 superview 多少个像素（传入常数时，将会设置成相对于其 superview 对应方位的距离），可能后续维护的时候会遇到一些问题。</p></blockquote><p>我进一步在主站内对上面进行尝试了一下，如果是同时进行自动布局的一个另一个 view2 对其的属性使用所写的方式，由于其没渲染完，一般会返回0，此时在某些情况下是不会有问题的，比如 view2 是 view1 的父 view，如下面的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line"><span class="built_in">UIView</span> *view2 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">[view1 addSubview:view2];</span><br><span class="line"></span><br><span class="line">[view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view1.top).mas_equalTo(<span class="number">10</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>此时由于 view1.top 取到的是 0，相当于设定 view2 的顶部距离其 superview 是 0+10，和预期是相同的。因此不会出错。</p><p>另一种可能性可能是看起来不会出错，比如设定相对于 view controller 里面 view 的 bottom：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in a view controller</span></span><br><span class="line"><span class="built_in">UIView</span> *view = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:view];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[view mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    ...</span><br><span class="line">    make.bottom.mas_equalTo(<span class="keyword">self</span>.view.bottom);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>假设根据分类的定义，这个时候 <code>self.view.bottom</code> 返回了 1000 其实相当于设置 <code>make.bottom.mas_equalTo(self.view.mas_bottom).mas_offset(1000)</code>，但由于多出的部分都在屏幕外面，因此看起来和正确的设置方式没有区别。</p><h3 id="NSArray-MASAdditions"><a href="#NSArray-MASAdditions" class="headerlink" title="NSArray+MASAdditions"></a>NSArray+MASAdditions</h3><p>同样提供了 <code>mas_makeConstraints</code>, <code>mas_updateConstraints</code> 和 <code>mas_remakeConstraints</code> 三个方法。通过数组调用这三个方法时，要保证数组中的所有元素都是 <code>UIView</code> 类型，这三个方法的调用内部会遍历整个数组内的所有 view，并针对每个 view 调用对应的方法来设置 view 的约束。</p><p>多提供了两个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedSpacing:(<span class="built_in">CGFloat</span>)fixedSpacing leadSpacing:(<span class="built_in">CGFloat</span>)leadSpacing tailSpacing:(<span class="built_in">CGFloat</span>)tailSpacing;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)mas_distributeViewsAlongAxis:(MASAxisType)axisType withFixedItemLength:(<span class="built_in">CGFloat</span>)fixedItemLength leadSpacing:(<span class="built_in">CGFloat</span>)leadSpacing tailSpacing:(<span class="built_in">CGFloat</span>)tailSpacing;</span><br></pre></td></tr></table></figure><p>也是通过计算并对每一个 view 调用 <code>mas_makeConstraints</code>。但我目前感觉不如使用 <a href="https://nshipster.com/uistackview/"><code>UIStackView</code></a>，并将 distribution 设置为 <code>UIStackViewDistributionEqualSpacing</code> 和 <code>UIStackViewDistributionFillEqually</code>。</p><blockquote><p>不过 stack view <a href="https://github.com/layoutBox/LayoutFrameworkBenchmark">性能相对于 autolayout 会稍微差一点</a>，但如果只有几个 view 感觉问题不是很大。</p></blockquote><blockquote><p>To be on the safe side, avoid using deeply nested stack views, especially in reusable views such as table and collection view cells. (See <a href="https://nshipster.com/uistackview/">nshipster</a>)</p></blockquote><h3 id="NSArray-MASShorthandAdditions"><a href="#NSArray-MASShorthandAdditions" class="headerlink" title="NSArray+MASShorthandAdditions"></a>NSArray+MASShorthandAdditions</h3><p>与 UIView+MASShorthandAdditions 类似，提供了在定义 <code>MAS_SHORTHAND</code> 宏前提下，可以在 <code>NSArray</code> 上调用 <code>makeConstraints</code> 来代替调用 <code>mas_makeConstraints</code>，调用 <code>updateConstraints</code> 来代替 <code>mas_updateConstraints</code> 和调用 <code>remakeConstraints</code> 来代替 <code>mas_remakeConstraints</code> 的能力。</p><h3 id="MASViewAttribute"><a href="#MASViewAttribute" class="headerlink" title="MASViewAttribute"></a>MASViewAttribute</h3><p>主要包括以下的一些属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The view which the reciever relates to. Can be nil if item is not a view.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) MAS_VIEW *view;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The item which the reciever relates to.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="type">id</span> item;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The attribute which the reciever relates to</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSLayoutAttribute</span> layoutAttribute;</span><br></pre></td></tr></table></figure><p><code>MAS_View</code> 实际上是一个 <code>UIView</code> 的别名，因此该类实际上封装了一个 view 和一个 attribute，对应了文章开头中自动布局公式中的一组 <code>Item&#39;s Attribute</code>。</p><h3 id="MASConstraint"><a href="#MASConstraint" class="headerlink" title="MASConstraint"></a>MASConstraint</h3><p>代表了一个未激活的 constraint，该类中提供了诸如 top，left 等方法，但其功能都需要在子类中实现。详细调用逻辑可以参考后面的实例分析部分。</p><h3 id="MASConstraintMaker"><a href="#MASConstraintMaker" class="headerlink" title="MASConstraintMaker"></a>MASConstraintMaker</h3><p>提供了一个 <code>install</code> 方法，该方法实际上调用了自己每个 <code>MASConstraint</code> 的 <code>install</code> 方法，如果 <code>removeExisting</code> 是 YES，先 <code>uninstall</code> 存在的 constraints，如果 <code>updateExisting</code> 是 YES，把每个 constraints 的 updateExisting 设置为 YES.</p><p>Maker 的属性如 left 调用的时候都相当于把对应的 attribute 添加到 maker 的 constraints 数组里面，并且返回一个 MASConstraints。</p><p>单个属性返回的是一个 <code>MASViewConstraint</code>，而组合属性如 edges 返回的是一个 <code>MASCompositeConstraint</code>。这两个都是 <code>MASConstraints</code> 的子类。实现了 <code>addConstraintWithLayoutAttribute</code> 方法和一些其他重要方法比如 <code>install</code>。</p><p>具体使用逻辑可以参考后面的实例分析部分。</p><h3 id="MASViewConstraint"><a href="#MASViewConstraint" class="headerlink" title="MASViewConstraint"></a>MASViewConstraint</h3><p>主要包括以下一些重要属性。</p><p>头文件里包括两个 <code>MASViewAttribute</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  First item/view and first attribute of the NSLayoutConstraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *firstViewAttribute;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Second item/view and second attribute of the NSLayoutConstraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *secondViewAttribute;</span><br></pre></td></tr></table></figure><p>.h 文件中的一些属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MAS_VIEW *installedView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) MASLayoutConstraint *layoutConstraint;</span><br><span class="line"><span class="comment">/// 两个 attribute 之间的关系，可能是等于，小于等于，大于等于</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSLayoutRelation</span> layoutRelation;</span><br><span class="line"><span class="comment">/// 限制的优先度，默认是 MASLayoutPriorityRequired</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) MASLayoutPriority layoutPriority;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> layoutMultiplier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> layoutConstant;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> hasLayoutRelation;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> mas_key;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="type">BOOL</span> useAnimator;</span><br></pre></td></tr></table></figure><p>初始化方法在 <code>MASConstraintMaker</code> 被调用，用来添加约束，约束默认的 <a href="https://developer.apple.com/documentation/uikit/uilayoutpriority?language=objc">priority</a> 都是 <code>MASLayoutPriorityRequired</code>。multipler 都是 1。</p><ul><li><code>left</code> 实际上调用的是 delegate 的 <code>- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code> 方法，delegate 是 <code>MASConstraintMaker</code>。里面把这个新的约束加到了 maker 的 constraints 数组里面的。</li><li><code>equalTo</code>，<code>greaterThanOrEqualTo</code> 和 <code>lessThanOrEqualTo</code> 都调用了 <code>equalToWithRelation</code>，但传入的第二个参数（layoutRelation）不一样，这个也是在子类里面被实现的。<code>equalTo</code> 后面嗯能用括号是因为返回的是一个 block。如果传入的是一个 view，设置自己的 layoutRelation 是 relation，secondAttribute 是那个传入的 view（如果传入的是一个 NSValue 或者 CGPoint，CGSize，将会先看 attribute 符不符合，然后更改 layoutConstant）。如果传入的是一个数组，会转换成一个 <code>MASCompositeConstraint</code>。</li><li><code>insets</code> 要传入一个 UIEdgeInset 参数，将会吧 firstAttribute 里面的对应参数变成 edgeInset 里面的值。<code>inset</code> 实际调用了一个 <code>insets</code> 并将 4 面都设置为传入的值。<code>offset</code> 更改了 <code>layoutConstant</code> 值。<code>mas_offset</code> 和之前的 <code>equalTo</code> 一样增加了 auto boxing，对于传入 view 和 number 有不同的处理。</li><li><code>with</code> 和 <code>and</code> 都直接返回 <code>self</code> 只是为了帮助链式调用的读法更加通顺。如 <code>make.width.and.height.equalTo(self.bottomView).with.priorityLow();</code>，实际使用时可以不写。</li><li><code>priorityLow</code> 实际上调用了 <code>.priority</code> 并将对应的优先级作为参数传入。</li></ul><p>具体如何被调用可以参考后文中的案例分析1和2。</p><h3 id="MASCompositeConstraint"><a href="#MASCompositeConstraint" class="headerlink" title="MASCompositeConstraint"></a>MASCompositeConstraint</h3><p>包含多个 <code>MASViewConstraint</code> 的一个 constraint，会在链式调用同时设置多个 attribute 时被创建，如 <code>make.left.and.right.equalTo(view).offset(@10)</code>。对于父类中的方法实现基本就是调用了包含的每一个 <code>MASViewConstraint</code> 的同名方法。</p><p>具体如何被生成可以参考后文中的案例分析3。</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><h4 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view2).mas_offset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>mas_makeConstraints</code> 的调用，创建了一个 <code>MASConstraintMaker</code> 实例，并且将其 <code>view</code> 属性设置为 <code>view1</code>。然后将该新建的 maker 作为参数传入到 block 中，调用整个 block。</p><p>调用 <code>.top</code> 分别创建了一个 attribute 和一个 constraints</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br></pre></td></tr></table></figure><p>并将这个 newConstraint 的 delegate 设置成 maker，再将其加入到 maker 的 <code>constraints</code> 数组中。并返回一个 <code>MASViewConstraints</code>，返回的就是 <code>newConstraint</code>，也就是说后面的链式操作实际上都是在对一个已加入到 constraints 数组的进行修改。</p><p><code>mas_equalTo</code> 调用了 <code>MASViewConstraints</code> 的 <code>equalToWithRelation</code> 方法，其第一个参数是一个 <code>id</code> 类型，这里将 <code>view2</code> 作为这个参数传入。方法中将会将 constraints 的 <code>layoutRelation</code> 设置为对应的 relation，这里是 <code>NSLayoutRelationEqual</code>。并且传入 <code>view2</code> 来设置 constraints 的 <code>secondAttribute</code> 属性。在 setter 中，新生成一个 <code>MASViewAttribute</code>，该 <code>MASViewAttribute</code> 的 <code>view</code> 就是 view2，而 <code>attribute</code> 和 view1 的 attribute 相同。最后也同样会返回一个 <code>MASConstraint</code>。</p><blockquote><p>如果 <code>equalTo</code> 里面是一个数字就会直接去设置 constraints 的 layoutConstant。</p></blockquote><p><code>mas_offset</code> 会把 <code>MASConstraint</code> 的 offset 设置为 10，offset 的 setter 方法会将 <code>layoutConstant</code> 设置为该常数，之后仍会返回一个 <code>MASConstraint</code>，但到了此时，一个 <code>MASConstraint</code> 的所有属性已经设置完成.</p><h4 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.top.mas_equalTo(view2.mas_bottom).mas_offset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>和上面基本一样，但此时设置 <code>secondAttribute</code> 的时候传入的是一个 <code>MASAttribute</code>，这个 attribute 的 <code>view</code> 和 <code>item</code> 属性都初始化为 <code>view2</code>，同时 <code>layoutAttribute</code> 属性被设置为 <code>NSLayoutAttributeBottom</code>。<code>secondAttribute</code> 被直接设置为这个 attribute。</p><h4 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">    make.leading.and.trailing.mas_equalTo(view2.mas_bottom).inset(<span class="number">10</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><code>make.leading.and</code> 和上面一样，往 maker 的 constraints 数组里面添加了一个 constraints。<code>MASConstraints</code> 的 <code>.trailing</code> 会调用其 <code>addConstraintWithLayoutAttribute</code> 方法，这个方法在子类中被实现，<code>MASViewConstraints</code>  的该方法调用了其 delegate 的 <code>- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code> 方法，也就是 <code>MASConstraintMaker</code> 的该方法。但和最开始 <code>make.leading</code> 调用所不同的是，之前的第一个参数 constraint 传的是 <code>nil</code>，现在传的是 <code>self</code> 也就是 <code>make.leading</code> 生成的 <code>MASConstraint</code>。此时会将两个 constraints 合成一个 <code>MASCompositeConstraint</code>，该类是 <code>MASConstraints</code>  的另一个子类。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class="line">MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">compositeConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line"><span class="keyword">return</span> compositeConstraint;</span><br></pre></td></tr></table></figure><p><code>MASCompositeConstraint</code> 的初始化方法中，将会把所有的 children 中的 constraint 的 delegate 设置为 compositeConstraint 自身。</p><p><code>shouldBeReplacedWithConstraint</code> 中将会把 maker 中的 constraints 属性中的 <code>constraint</code> 替换成 <code>compositionConstraint</code>。</p><p>最后一个 <code>MASCompositeConstraints</code> 将会被返回。</p><p>如果我们继续添加属性，比如在 <code>trailing</code> 后添加 <code>.bottom</code>，此时调用的是 <code>MASCompositeConstraint</code> 的 <code>addConstraintWithLayoutAttribute</code> 的方法。里面调用了 <code>MASConstraintsMaker</code> 的 <code>[strongDelegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute]</code> 方法（<code>strongDelegate</code> 就是 compositeConstraints 的 delegate，也就是 maker。由于第一个参数不是一个 <code>nil</code> 也不是 <code>viewConstraints</code>，会直接返回一个 <code>MASConstraint</code> 并被 <code>MASCompositeConstraints</code> 加入到 children 数组中。</p><p><code>MASCompositeConstraints</code> 的 <code>inset</code> 或者 <code>offset</code> 方法会遍历所有的 children 中的并调用对应的方法（<code>inset</code> 或者 <code>offset</code>）最终其实和之前的 mas_offset 一样都是对 constraint 的 layoutConstant 属性进行了设置，inset 只是帮你在 bottom，trailing 和 bottom 的情况下加上了负号。</p><h4 id="最后步骤"><a href="#最后步骤" class="headerlink" title="最后步骤"></a>最后步骤</h4><p>上面三个案例的 block 执行结束后都会调用 maker 的 <code>install</code> 方法。其定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)install &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</span><br><span class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</span><br><span class="line">            [constraint uninstall];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSArray</span> *constraints = <span class="keyword">self</span>.constraints.copy;</span><br><span class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> constraints) &#123;</span><br><span class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.constraints removeAllObjects];</span><br><span class="line">    <span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeExisting</code> 和 <code>updateExisting</code> 会在调用 <code>mas_remakeConstraints</code> 和 <code>mas_updateConstraints</code> 的时候被设置。可以看到 install 就是遍历自己的 constraints 数组（都是在 block 里面添加的），并对里面的每一个 constraint 调用 install 方法（该方法都在子类里面实现）。</p><p><code>MASViewConstraints</code> 对于 install 的实现步骤如下：</p><ol><li>分别拿出 firstAttribute 和 secondAttribute 中的 item（item1，item2） 和 attribute（attribute1，attribute2），如果 second attribute 为 nil（比如 <code>make.left.equalTo(@10)</code>)，会将 item2 设置为 item1 的 superview，attribute2 设置为 attribute1。</li><li>调用系统方法获得一个 layout constraints</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MASLayoutConstraint *layoutConstraint <span class="comment">// MASLayoutConstraint 是一个 NSLayoutConstraint 的子类</span></span><br><span class="line">        = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line">                                        attribute:firstLayoutAttribute</span><br><span class="line">                                        relatedBy:<span class="keyword">self</span>.layoutRelation</span><br><span class="line">                                           toItem:secondLayoutItem</span><br><span class="line">                                        attribute:secondLayoutAttribute</span><br><span class="line">                                       multiplier:<span class="keyword">self</span>.layoutMultiplier</span><br><span class="line">                                         constant:<span class="keyword">self</span>.layoutConstant];</span><br><span class="line">layoutConstraint.priority = <span class="keyword">self</span>.layoutPriority;</span><br></pre></td></tr></table></figure><ol start="3"><li>查找这个 constraints 的 installedView（被添加到的 view 上，如果 item1，item2都是 view，那就是他们共同的 superview，从这一点也可以看出只有拥有同一个 superview 的两个 view 之间才能添加属性约束（包括一个是另一个的 superview）；如果 attribute1 是某种 size 属性，那就是 item1；如果 item2 不存在那就是 item1 的父 view）是否有相同的 layoutConstraint</li></ol><p>如果存在同样的 layoutConstraint，就更新对应的 layoutConstraint，因此使用 <code>mas_updateConstraints</code> 要注意只能帮你更新只修改 constant 的 constraint。</p><blockquote><p>要求该 constraint 的 firstItem, secondItem, firstAttribute, secondAttribute, relation, multiplier, priority 一样。</p></blockquote><ol start="4"><li>如果没有相同的 constraints 就对该 constraints 进行激活。</li></ol><p><code>MASCompositeConstraint</code> 的 <code>install</code> 实际上就是遍历 children 里面的所有 constraints 并调用其 install 方法。</p><h4 id="案例总结"><a href="#案例总结" class="headerlink" title="案例总结"></a>案例总结</h4><ul><li><code>mas_makeConstraints</code> block 中的一条语句会生成一个 <code>MASConstraints</code> 的子类，如果是单个约束会生成一个 <code>MASViewConstraints</code>，如果是多个约束会生成一个 <code>MASCompositeConstraint</code>（实际内部还是包括了很多个 <code>MASViewConstraints</code>）。</li><li><code>view.mas_top</code> 这样的语句返回的是一个 <code>MASAttribute</code>。</li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="使用-inset-还是-mas-offset"><a href="#使用-inset-还是-mas-offset" class="headerlink" title="使用 inset 还是 mas_offset"></a>使用 <code>inset</code> 还是 <code>mas_offset</code></h4><p>实际实现都是一样的，都设置了 constraint 的 layoutConstant 属性，但 <code>inset</code> 会在 trailing，right 和 bottom 的时候添加负号。</p><h4 id="mas-equalTo-和-equalTo"><a href="#mas-equalTo-和-equalTo" class="headerlink" title="mas_equalTo 和 equalTo"></a><code>mas_equalTo</code> 和 <code>equalTo</code></h4><p><code>mas_equalTo</code> 是一个定义的宏，将会对传入值进行 autoboxing 成 <code>NSNumber</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> mas_equalTo(...)                 equalTo(MASBoxValue((__VA_ARGS__)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value)) <span class="comment">// In MASUtilities.h</span></span></span><br></pre></td></tr></table></figure><p><a href="https://nshipster.cn/type-encodings/"><code>@encode</code></a> 得到值的类型，通过可变参数列表，使用 <code>strcmp</code> 对比参数和类型，相同时就将参数转换成该类型。</p><blockquote><p><code>MASConstraint (AutoboxingSupport)</code> 中也定义了一个 <code>mas_equal</code> ）将其实现为和 <code>equalTo</code> 一致。实际调用的时候都是用的宏，添加一个同名的方法能够使宏能够有自动补全的能力。</p></blockquote><h4 id="使用-trailing-还是-right"><a href="#使用-trailing-还是-right" class="headerlink" title="使用 trailing 还是 right"></a>使用 <code>trailing</code> 还是 <code>right</code></h4><p>大多数情况下含义一样，但要注意对于一些从右到左的语言，比如阿拉伯语，<code>trailing</code> 实际代表的是 <code>left</code>。基本上使用 <code>trailing</code> 总是更保险的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍了一些关于 iOS 自动布局的概念，并对 Masonry 框架进行了分析。主要介绍了 Masonry 框架主要结构，使用时内部调用过程和一些需要注意的细节。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
